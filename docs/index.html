<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Henry Widd&#39;s Blog</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="application/atom+xml" rel="alternate" href="atom.xml" title="Henry Widd&#39;s Blog">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-clojure.min.js"></script>
    <script type="text/javascript" src="https://livejs.com/live.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css">



    <!-- Social sharing (Facebook, Twitter, LinkedIn, etc.) -->
    <meta name="title" content="Henry Widd&#39;s Blog">
    <meta name="twitter:title" content="Henry Widd&#39;s Blog">
    <meta property="og:title" content="Henry Widd&#39;s Blog">
    <meta property="og:type" content="website">

    <meta name="description" content="Miscellania">
    <meta name="twitter:description" content="Miscellania">
    <meta property="og:description" content="Miscellania">


    <meta name="twitter:url" content="https://widdindustries.com/blog/index.html">
    <meta property="og:url" content="https://widdindustries.com/blog/index.html">


    <meta name="twitter:card" content="summary">


    <meta name="twitter:creator" content="henryw374">


    <meta name="twitter:site" content="henryw374">

  </head>
  <body>

    <div class="site-header">
      <div class="wrapper">
        <div class="site-nav">
          <a class="page-link" href="archive.html">Archive</a>
          <a class="page-link" href="tags/index.html">Tags</a>
          <a class="page-link" href="https://github.com/henryw374/blog/discussions/categories/posts">Discuss</a>
	  <a class="page-link" href="atom.xml">
            Feed
          </a>
	  
	  <a class="page-link" href="https://twitter.com/henryw374">
            Twitter
          </a>
	  
	  
	  <a class="page-link" href="https://widdindustries.com/about">About</a>
	  
        </div>
        <div>
          <h1 class="site-title">
            <a class="page-link" href="index.html">Henry Widd&#39;s Blog</a>
          </h1>
	  <p>Miscellania</p>
        </div>
      </div>
    </div>

    <div class="wrapper">

      <div>
<h1>
  
  <a href="taming-a-clojurescript-megabuild-with-shadow-and-kaocha.html">
  
  Taming a Clojurescript mega-project with Shadow and Kaocha
  
  </a>
  
</h1>
<p>In this post I am going to look at applying my regular dev setup to a project with a lot of code and tests that take a very long time to run.</p><p>Firstly, here are my Clojurescript dev setup requirements:</p><ul><li>run a single test from the IDE - ie the one under the cursor</li><li>run all tests in namespace similar to above</li><li>run any subset of tests based on ns-pattern</li><li>see nicely formatted test output - for example clearly highlighting the diff in expected/actual maps</li><li>tests in CI output a standard format like junit xml, so results can be interpreted by CI tool</li><li>tests in CI can run under advanced compilation (so as to be similar to the production build)</li><li>fast incremental compile+reload</li></ul><p>Anything you'd add? If so please see link at the bottom for how to discuss</p><p>I should also say that I'm generally developing in multi-person teams building SPA's with considerable business complexity. However, the list is still the same even for my own open source or hobby projects, but in some situations not everything above is a must-have. For example, if you only have a small number of fast-running tests then the items above about running subsets of tests will not be so important. </p><p>I recently started to do some work on a project with around 800 Clojurescript (browser) tests - which in itself may not sound massive, but there are a number of slower DOM-clicking tests, so total test-run time above 20 minutes. It goes without saying that one would not want to run all the tests in one go - but this fact meant that builds and tests had been split apart and this had led to quite a bit of complexity in the build setup: Local dev was done with figwheel+webpack, configured with multiple <a href='https://figwheel.org/docs/extra_mains.html'>extra mains</a>, and shadow+karma in the CI environment. </p><p>With the existing build setup, on saving a file you could be waiting 10+ seconds to see the incremental build finish - ouch! To run a single test required knowing which figwheel 'extra-main' the test would be compiled into and loading the auto-test browser page for that, and then doing some other steps I'm not even going to get into... all in all, not ideal. </p><p>So... what to do? My preferred Clojurescript build and test setup for the past couple of years has been shadow plus kaocha-cljs2. Everyone knows shadow of course, but <a href='https://github.com/lambdaisland/kaocha-cljs2'>kaocha-cljs2</a> seems weirdly unstarred (< 20) and un-discussed on the interwebs. The combination of these two gives me the above wishlist of course - that's why I chose it. But how well would it scale to the new megaproject? How easy would it be to set up?</p><h2>Setup</h2><p>Possibly one reason kaocha-cljs2 seems under-appreciated is that by design there are more moving parts compared to other Clojurescript test setups I have used - for example one needs an extra server (Funnel) for 2-way communication between jvm and js environments. </p><p>However, setup couldn't have been easier - and that's because I have a little ready-made shadow+kaocha_cljs2 template that I use in all my projects and libraries. I've called this template <a href='https://github.com/henryw374/tiado-cljs2'>tiado-cljs2</a> and if you want to try it on your project, you'll have it up and running in minutes - see the README for instructions.</p><h2>Does it scale?</h2><p>In the way I set up Shadow on this project, there are 4 'watches' going at once, one for the main app, one for tests and a couple of others for some miscellaneous apps. Shadow incrementally compiles just what is needed so if changing a test file, just the test build kicks in. So compared to the old build, incremental compile is often around 5-10x faster. </p><p>When it comes to the tests, I have used kaocha suites to split the tests based on ns-patterns - which in CI can be run concurrently. Kaocha-cljs2 doesn't support 'ns-patterns' out of the box yet (as kaocha does for clojure tests) - but luckily kaocha supports user-defined hooks so <a href='https://github.com/lambdaisland/kaocha-cljs2/issues/32'>adding it was not difficult</a>.</p><p>With these mega test-suites, the default timeout was not enough. User-defined timeouts are not currently respected by kaocha-cljs2 - so <a href='https://github.com/lambdaisland/kaocha-cljs2/issues/31'>a little monkey patching was needed</a>.</p><p>As well as running individual suites, the holy grail of clojurescript testing is surely having an IDE hotkey to run the test under the caret. This is achieved with a simple macro invoking <code>&#40;kaocha.repl/run xxx&#41;</code> - a macro was required (rather than a function) so that it can be invoked when either in a cljs or clj repl.</p><p>I could have had multiple test watches instead of one - each watching a subset of tests (this is a shadow feature). However the single one works well enough and makes life easier for developers as there is just a single place for tests to run.</p><p>So, whilst compilation and test-running times still seem a bit bigger compared to what I'm used to, the whole thing now feels far more manageable. There may be scope for modularization of the app  - I don't know yet, but I'm much happier to investigate that and experiment with a solid, speedier build+test setup. </p><h2>Finally</h2><p>The fact that all this works as well as it does is thanks to the shadow and kaocha maintainers of course. Clojurescript would not be in such a good place without them!</p>
<p>Discuss this post <a href="">here</a>.</p>
<p><i>Published: 2023-08-17</i></p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/clojure.html">clojure</a>
  </span>
  
  </i>
</p>


</div>
<div>
<h1>
  
  <a href="what-is-inst.html">
  
  What is #inst ?
  
  </a>
  
</h1>
<p>This post looks at the meaning of the <code>#inst</code> reader literal from <a href='https://github.com/edn-format/edn'>Extensible Data Notation</a> (hereafter referred to as 'edn'), how it behaves by default in Clojure(script) and when it might not be sufficient for representing date/time information.</p><p>The majority of the content of this post comes from the Rationale section of <a href='https://github.com/henryw374/time-literals'>time-literals</a>, a Clojure(Script) library which provides tagged literals for java.time objects.</p><h2>What is #inst ?</h2><p>Support for edn and its Reader Literals were a headline addition in <a href='https://github.com/clojure/clojure/blob/master/changes.md#21-reader-literals'>Clojure 1.4</a> and with that came built-in support for the <a href='https://github.com/clojure/clojure/blob/master/changes.md#211-instant-literals'>#inst tag</a>. The <code>#inst</code> tag is a part of the edn spec, where it is defined as representing <a href='https://github.com/edn-format/edn#inst-rfc-3339-format'>an instant in time</a>, which means a point in time relative to UTC that is given to (at least) millisecond precision. The format of <code>#inst</code> is RFC3339, which is <a href='https://medium.com/easyread/understanding-about-rfc-3339-for-datetime-formatting-in-software-engineering-940aa5d5f68a'>like ISO8601 but slightly wider</a>.</p><p>In Clojure(script), <code>#inst</code> is read as a legacy platform <code>Date</code> object by default, but as is made clear by the edn spec and by <a href='https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/AreasOfInterestForClojuresCore.md#extensible-reader'>this talk from Rich Hickey</a> the default implementation is just that: <code>#inst</code> may be read to whatever internal representation is useful to a consuming program. For example a program running on the jvm could read <code>#inst</code> tags to java.time.Instant (or java.time.OffsetDateTime if wanting to preserve the UTC offset information). It seems to me unfortunate that Clojure(script) provided defaults for <code>#inst</code> because users may not realise it is 'just a default', but that's just my opinion. My guess is that Clojure is trying to be both simple and easy in this case.</p><p>Although edn readme doesn't say this explicitly, to avoid 'reinventing the wheel', when conveying data using edn format, built-in elements seem to me to be preferable to user defined elements. For example, if one wants to convey a map, <code>{:a 1 :b 2}</code> is preferred to <code>#foo/map &quot;&#91;&#91;:a 1&#93; &#91;:b 2&#93;&#93;&quot;</code>  - unless of course one wanted to convey something additional about the map, ordering perhaps. Similarly, if conveying an <code>instant in time</code> use <code>#inst</code>.</p><h2>When the default is not enough</h2><p>There are two situations where reader literals are useful:</p><ol><li>Conveying <code>edn</code> data between processes</li><li>REPL I/O (iow "working at the REPL")</li></ol><p>Although they have many similarities and overlap, Clojure allows these cases to be considered separately and for good reason, as explained below: </p><h3>The need for more Tagged Elements representing Dates in edn</h3><p>There are many kinds of things relating to date and time that are not an <code>instant in time</code>, so <code>#inst</code> would not be an appropriate way to tag them. For example the month of a particular year such as 'January 1990' or a calendar date such as 'the first of June, 3030'. There are no built-in edn tags for these but tags can be provided in the user space, as they are by the <a href='https://github.com/henryw374/time-literals'>the time-literals</a> library.</p><p>Note that the default Clojure reader behaviour is to accept partially specified instants, such as <code>#inst &quot;2020&quot;</code> (and read that to a Date with millisecond precision) - but this is specific to the Clojure implementation and not valid edn (ie not RFC3339).</p><h3>Round-tripping at the REPL</h3><p>Clojure provides two mechanisms for printing objects - abstract and concrete as this code printing the same object shows:</p><pre><code class="lang-clojure">&#40;let &#91;h &#40;java.util.HashMap.&#41;&#93;
  {:abstract &#40;pr-str h&#41;
   :concrete &#40;binding &#91;&#42;print-dup&#42; true&#93;
               &#40;pr-str h&#41;&#41;}&#41;
=&gt; {:abstract &quot;{}&quot;, :concrete &quot;#=&#40;java.util.HashMap. {}&#41;&quot;}
</code></pre><p>The concrete representation is sometimes useful to know and also the string output can be passed back to the reader to recreate the same internal representation again, which is known as <code>round-tripping</code>.</p><p>The default readers and printers of platform date objects don't allow round-tripping, <a href='https://ask.clojure.org/index.php/11898/printing-and-reading-date-types'>the reason for which is unknown</a>.</p><p>This is relevant to the two java.time types which logically correspond to <code>#inst</code> (java.time.Instant and java.time.OffsetDateTime). The <a href='https://github.com/henryw374/time-literals'>the time-literals</a> library contains specific readers and printers for those objects so that they do round-trip. </p><p>When conveying these objects in edn format, they should be tagged as <code>#inst</code> (as per above argument about preferring built-in elements). To do that with <code>time-literals</code>, simply provide your own implementation of <code>clojure.core/print-method</code> for Instant and/or OffsetDateTime. With <code>&#42;print-dup&#42;</code> true, the concrete type will still be printed.</p><h2>When reader literals are NOT useful</h2><p>Consider this code from a Clojure namespace:</p><pre><code class="lang-clojure">&#40;ns foo.bar&#41;

&#40;def one-day #time/period &quot;P1D&quot;&#41;

&#40;defn one-more-day &#91;period&#93;
  &#40;-&gt; period &#40;.plusDays 1&#41;&#41;&#41;

</code></pre><p>Now answer:</p><ol><li>Will it compile?</li><li>If it can be made to compile, will <code>&#40;one-more-day one-day&#41;</code> work?</li></ol><p>Go back and have a look if required, I will reveal the answer in the next sentence</p><p>The answer to 1. is maybe, ie only if <code>&#42;data-readers&#42;</code> contains a mapping for <code>time/period</code> AND the reader function is already loaded in the process. Just having a mapping in data_readers.cljc is not enough. Add a side-effecting require for that reader function you say? No thanks.</p><p>The answer to 2. is again maybe. If the mapping for <code>time/period</code> is set up AND the reader function returned a java.time.Period then it will work. </p><p>So tl;dr reader literals in code can be made to work but is not good practice IMHO. That goes for user-defined literals but also <code>#inst</code> and <code>#uuid</code>. Typing a few extra characters to call the actual constructor function directly is not so hard. </p><p>I don't mean I never have files with literals in them, but not in code I expect anybody else (incl. myself at a later date) to just be able to 'pick up and run'. If I'm flowing around in my own space then it's fine. If I get to 'crystalising stuff out' - e.g. to tests for CI, then I replace any literals.</p><p>Btw if you want to do a find/replace for <code>#inst</code> in your source files then <code>clojure.instant/read-instant-date</code> or <code>cljs.reader/parse-timestamp</code> are probably the functions you need ;-)</p>
<p>Discuss this post <a href="">here</a>.</p>
<p><i>Published: 2023-06-14</i></p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/clojure.html">clojure</a>
  </span>
  
  <span class="tag">
    <a href="tags/date-time.html">date-time</a>
  </span>
  
  </i>
</p>


</div>
<div>
<h1>
  
  <a href="logging-data.html">
  
  Log data, not strings - with SLF4J
  
  </a>
  
</h1>
<p>A recent release of the popular Java logging abstraction SLF4J has a new API enabling <a href='https://stackify.com/what-is-structured-logging-and-why-developers-need-it/'>structured logging</a>. New Clojure logging macros using this, e.g. <code>&#40;log/info &quot;request-for-help&quot; {&quot;priority&quot; &quot;high&quot;}&#41;</code> are available as <a href='https://github.com/henryw374/slf4clj'>slf4clj</a>.</p><h1>Why Log data?</h1><p>A couple of years ago I made a survey of all the logging libraries one might use from Clojure. The majority of contenders (<a href='https://github.com/clojure/tools.logging'>clojure.tools.logging</a> foremost among them) I ruled out fairly early because they only log strings, not data.</p><p>To explain this limitation, in all logging frameworks you can format messages as json or something and get <code>{level: &quot;INFO&quot;, message &quot;Commissioner Gordon called because Gotham city is under attack from the Joker&quot;}</code>. Whilst useful, what is more queryable is to log arbitrary data (key value pairs) and have that data passed as-is to appenders, which might serialise to json, or write to a database. An equivalent message formatted as JSON might be <code>{level: &quot;INFO&quot;, message-type: &quot;request for help&quot;, urgency: &quot;high&quot;, caller: &quot;Commissioner Gordon&quot;, foe: &quot;Joker&quot;, target:&quot;Gotham&quot; }</code>. Assuming you're not still shelling into boxes and grepping log files, IMO <a href='https://stackify.com/what-is-structured-logging-and-why-developers-need-it/'>structured log data</a> is something you can't go back from.</p><h1>Options for Logging data from Clojure</h1><p>The requirement to log data left two main contenders, <a href='https://github.com/BrunoBonacci/mulog'>MuLog</a> and <a href='https://logging.apache.org/log4j/2.x/'>Log4j2</a>. At the time I decided Log4j2 seemed like  the boring, safe choice. Well, that didn't turn out to be quite right haha! </p><p>As a result of opting for Log4j2, I put some <a href='https://github.com/henryw374/clojure.log4j2'>helper functions in a lib</a> for Clojure users writing log statements against Log4j2. Note: the <a href='https://github.com/henryw374/clojure.log4j2'>README</a> for those contains more detailed comparison of existing Clojure logging libraries.</p><p>Released since I made that review, and created as a result of log4shell is <a href='https://github.com/amperity/dialog'>Amperity's Dialog</a> which is a logging backend for <a href='https://www.slf4j.org/'>slf4j</a>(1.x, string based) - the de facto Java logging facade. Dialog also provides a <a href='https://github.com/amperity/dialog/blob/main/src/clojure/dialog/logger.clj'>Logging API based on logging strings</a> or suggests you use clojure.tools.logging (strings again).</p><h1>Logging from Library Code</h1><p>Log4j2 is a 'logging implementation' or 'backend'. Ideally one would write log statements against a logging abstraction, where log statements get channeled to whatever logging backend is in place. This is especially important when writing library code. Users of e.g. <a href='https://github.com/ptaoussanis/carmine'>Carmine</a> will find logs coming via Timbre whether they like it or not. </p><p>Looking at the options here, assuming we want to log data ofc, MuLog might be a choice. It has be made to plug into an <a href='https://gitlab.com/nonseldiha/slf4j-mulog'>slf4j 1.x backend</a>, so surely can be made to plug into other things.</p><p>The most obvious choice though is <a href='https://www.slf4j.org/'>SLF4J</a>, apparently <a href='https://en.wikipedia.org/wiki/SLF4J'>the most popular Java library of any kind</a>. The 1.x version of this has been around for a long time and as you'd expect from an API dating from the noughties it only logs strings. With the 2.0 release, that has changed.</p><h1>Logging data with Slf4j</h1><p>Enter slf4j 2.0 - which was released toward the end of 2022. The 2.0 version of this popular logging facade newly includes an <a href='https://www.slf4j.org/manual.html#fluent'>API for logging data</a>, whilst remaining backwards compatible with the 1.x API.</p><p>The fluent API contains the <code>addKeyValue&#40;String key, Object value&#41;</code> method for structured logging. It's up to implementations as to what to do with the structured data. They may merge it to the <a href='https://www.slf4j.org/api/org/slf4j/MDC.html'>MDC</a> for that message for example as Log4j2-slf4j bridge does. The MDC is a map of String->String though, which is a problem if the value happens to be anything other than a string.</p><p>It is straightforward to use from Clojure as-is, but there are some convenience macros released as a new library <a href='https://github.com/henryw374/slf4clj'>slf4clj</a>. The aim is not to re-create the whole API, just offer some shorthand for the majority of use cases.</p><p>As you'd expect there are macros for <code>debug</code>, <code>info</code>, <code>warn</code> etc and the args for each are deliberately the same as Clojure's <a href='https://clojuredocs.org/clojure.core/ex-info'>ex-info</a>, namely  <code>&#40;&lt;level&gt; msg map&#41;</code> or <code>&#40;&lt;level&gt; msg map cause&#41;</code>.</p><p>Here is an example:</p><pre><code class="lang-clojure">&#40;require '&#91;com.widdindustries.slf4clj.core :as log&#93;&#41;

&#40;log/info &quot;request-for-help&quot; {&quot;urgency&quot; &quot;high&quot;, &quot;caller&quot; &quot;Commissioner Gordon&quot;, &quot;foe&quot; &quot;Joker&quot;, &quot;target&quot; &quot;Gotham&quot;}&#41;
</code></pre><h2>Migration path</h2><p>If you're using clojure.tools.logging, you can keep your existing setup and just start writing slj4j 2.0 logging statements and that will likely 'just work' in that the data will get printed out in some string format according to your pattern config). Separately you can change your logging backend to  something that does more with structured logs than just turning them into strings, like writing them as JSON for example.</p><h1>Logging APIs bundled with the JVM</h1><p>If you're logging from a library it is possible to avoid having any logging dependency by using APIs included with the jvm.</p><p>java.util.logging (JUL) is the one you have most likely heard of. As you might guess though for something created in the early part of this century, it is a string-based logging API. <a href='https://stackoverflow.com/questions/11359187/why-not-use-java-util-logging'>This question on Stackoverflow</a> goes into some details about JUL but in the threads is mention of a newer platform Logging facade called <a href='https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.Logger.html'>System.Logger</a> - which might be interesting but doesn't seem to have gained traction AFAICT.</p><h1>References</h1><ul><li><a href='https://mccue.dev/pages/12-3-22-better-java-logging-2'>Better Java Logging</a></li></ul><h1>Unrelated FYI</h1><p>This is my first blog post since moving to <a href='https://github.com/borkdude/quickblog'>Quickblog</a> - a blogging tool powered by Clojure - thanks Borkdude!</p>
<p>Discuss this post <a href="">here</a>.</p>
<p><i>Published: 2023-02-09</i></p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/clojure.html">clojure</a>
  </span>
  
  </i>
</p>


</div>

      
      <div style="margin-bottom: 20px; float: right;">
        <a class="page-link" href="archive.html">Archive</a>
      </div>
      
    </div>
  </body>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2X3CK9F000"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2X3CK9F000');
</script>
</html>
