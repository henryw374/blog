<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Henry Widd&#39;s Blog</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="application/atom+xml" rel="alternate" href="atom.xml" title="Henry Widd&#39;s Blog">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-clojure.min.js"></script>
    <script type="text/javascript" src="https://livejs.com/live.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css">



    <!-- Social sharing (Facebook, Twitter, LinkedIn, etc.) -->
    <meta name="title" content="Henry Widd&#39;s Blog">
    <meta name="twitter:title" content="Henry Widd&#39;s Blog">
    <meta property="og:title" content="Henry Widd&#39;s Blog">
    <meta property="og:type" content="website">

    <meta name="description" content="Miscellania">
    <meta name="twitter:description" content="Miscellania">
    <meta property="og:description" content="Miscellania">


    <meta name="twitter:url" content="https://widdindustries.com/blog/index.html">
    <meta property="og:url" content="https://widdindustries.com/blog/index.html">


    <meta name="twitter:card" content="summary">


    <meta name="twitter:creator" content="henryw374">


    <meta name="twitter:site" content="henryw374">

  </head>
  <body>

    <div class="site-header">
      <div class="wrapper">
        <div class="site-nav">
          <a class="page-link" href="archive.html">Archive</a>
          <a class="page-link" href="tags/index.html">Tags</a>
          <a class="page-link" href="https://github.com/henryw374/blog/discussions/categories/posts">Discuss</a>
	  <a class="page-link" href="atom.xml">
            Feed
          </a>
	  
	  <a class="page-link" href="https://twitter.com/henryw374">
            Twitter
          </a>
	  
	  
	  <a class="page-link" href="https://widdindustries.com/about">About</a>
	  
        </div>
        <div>
          <h1 class="site-title">
            <a class="page-link" href="index.html">Henry Widd&#39;s Blog</a>
          </h1>
	  <p>Miscellania</p>
        </div>
      </div>
    </div>

    <div class="wrapper">

      <div>
<h1>
  
  <a href="what-is-inst.html">
  
  What is #inst ?
  
  </a>
  
</h1>
<p>This post looks at the meaning of the <code>#inst</code> reader literal from <a href='https://github.com/edn-format/edn'>Extensible Data Notation</a> (hereafter referred to as 'edn'), how it behaves by default in Clojure(script) and when it might not be sufficient for representing date/time information.</p><p>The majority of the content of this post comes from the Rationale section of <a href='https://github.com/henryw374/time-literals'>time-literals</a>, a Clojure(Script) library which provides tagged literals for java.time objects.</p><h2>What is #inst ?</h2><p>Support for edn and its Reader Literals were a headline addition in <a href='https://github.com/clojure/clojure/blob/master/changes.md#21-reader-literals'>Clojure 1.4</a> and with that came built-in support for the <a href='https://github.com/clojure/clojure/blob/master/changes.md#211-instant-literals'>#inst tag</a>. The <code>#inst</code> tag is a part of the edn spec, where it is defined as representing <a href='https://github.com/edn-format/edn#inst-rfc-3339-format'>an instant in time</a>, which means a point in time relative to UTC that is given to (at least) millisecond precision. The format of <code>#inst</code> is RFC3339, which is <a href='https://medium.com/easyread/understanding-about-rfc-3339-for-datetime-formatting-in-software-engineering-940aa5d5f68a'>like ISO8601 but slightly wider</a>.</p><p>In Clojure(script), <code>#inst</code> is read as a legacy platform <code>Date</code> object by default, but as is made clear by the edn spec and by <a href='https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/AreasOfInterestForClojuresCore.md#extensible-reader'>this talk from Rich Hickey</a> the default implementation is just that: <code>#inst</code> may be read to whatever internal representation is useful to a consuming program. For example a program running on the jvm could read <code>#inst</code> tags to java.time.Instant (or java.time.OffsetDateTime if wanting to preserve the UTC offset information). It seems to me unfortunate that Clojure(script) provided defaults for <code>#inst</code> because users may not realise it is 'just a default', but that's just my opinion. My guess is that Clojure is trying to be both simple and easy in this case.</p><p>Although edn readme doesn't say this explicitly, to avoid 'reinventing the wheel', when conveying data using edn format, built-in elements seem to me to be preferable to user defined elements. For example, if one wants to convey a map, <code>{:a 1 :b 2}</code> is preferred to <code>#foo/map &quot;&#91;&#91;:a 1&#93; &#91;:b 2&#93;&#93;&quot;</code>  - unless of course one wanted to convey something additional about the map, ordering perhaps. Similarly, if conveying an <code>instant in time</code> use <code>#inst</code>.</p><h2>When the default is not enough</h2><p>There are two situations where reader literals are useful:</p><ol><li>Conveying <code>edn</code> data between processes</li><li>REPL I/O (iow "working at the REPL")</li></ol><p>Although they have many similarities and overlap, Clojure allows these cases to be considered separately and for good reason, as explained below: </p><h3>The need for more Tagged Elements representing Dates in edn</h3><p>There are many kinds of things relating to date and time that are not an <code>instant in time</code>, so <code>#inst</code> would not be an appropriate way to tag them. For example the month of a particular year such as 'January 1990' or a calendar date such as 'the first of June, 3030'. There are no built-in edn tags for these but tags can be provided in the user space, as they are by the <a href='https://github.com/henryw374/time-literals'>the time-literals</a> library.</p><p>Note that the default Clojure reader behaviour is to accept partially specified instants, such as <code>#inst &quot;2020&quot;</code> (and read that to a Date with millisecond precision) - but this is specific to the Clojure implementation and not valid edn (ie not RFC3339).</p><h3>Round-tripping at the REPL</h3><p>Clojure provides two mechanisms for printing objects - abstract and concrete as this code printing the same object shows:</p><pre><code class="lang-clojure">&#40;let &#91;h &#40;java.util.HashMap.&#41;&#93;
  {:abstract &#40;pr-str h&#41;
   :concrete &#40;binding &#91;&#42;print-dup&#42; true&#93;
               &#40;pr-str h&#41;&#41;}&#41;
=&gt; {:abstract &quot;{}&quot;, :concrete &quot;#=&#40;java.util.HashMap. {}&#41;&quot;}
</code></pre><p>The concrete representation is sometimes useful to know and also the string output can be passed back to the reader to recreate the same internal representation again, which is known as <code>round-tripping</code>.</p><p>The default readers and printers of platform date objects don't allow round-tripping, <a href='https://ask.clojure.org/index.php/11898/printing-and-reading-date-types'>the reason for which is unknown</a>.</p><p>This is relevant to the two java.time types which logically correspond to <code>#inst</code> (java.time.Instant and java.time.OffsetDateTime). The <a href='https://github.com/henryw374/time-literals'>the time-literals</a> library contains specific readers and printers for those objects so that they do round-trip. </p><p>When conveying these objects in edn format, they should be tagged as <code>#inst</code> (as per above argument about preferring built-in elements). To do that with <code>time-literals</code>, simply provide your own implementation of <code>clojure.core/print-method</code> for Instant and/or OffsetDateTime. With <code>&#42;print-dup&#42;</code> true, the concrete type will still be printed.</p><h2>When reader literals are NOT useful</h2><p>Consider this code from a Clojure namespace:</p><pre><code class="lang-clojure">&#40;ns foo.bar&#41;

&#40;def one-day #time/period &quot;P1D&quot;&#41;

&#40;defn one-more-day &#91;period&#93;
  &#40;-&gt; period &#40;.plusDays 1&#41;&#41;&#41;

</code></pre><p>Now answer:</p><ol><li>Will it compile?</li><li>If it can be made to compile, will <code>&#40;one-more-day one-day&#41;</code> work?</li></ol><p>Go back and have a look if required, I will reveal the answer in the next sentence</p><p>The answer to 1. is maybe, ie only if <code>&#42;data-readers&#42;</code> contains a mapping for <code>time/period</code> AND the reader function is already loaded in the process. Just having a mapping in data_readers.cljc is not enough. Add a side-effecting require for that reader function you say? No thanks.</p><p>The answer to 2. is again maybe. If the mapping for <code>time/period</code> is set up AND the reader function returned a java.time.Period then it will work. </p><p>So tl;dr reader literals in code can be made to work but is not good practice IMHO. That goes for user-defined literals but also <code>#inst</code> and <code>#uuid</code>. Typing a few extra characters to call the actual constructor function directly is not so hard. </p><p>I don't mean I never have files with literals in them, but not in code I expect anybody else (incl. myself at a later date) to just be able to 'pick up and run'. If I'm flowing around in my own space then it's fine. If I get to 'crystalising stuff out' - e.g. to tests for CI, then I replace any literals.</p><p>Btw if you want to do a find/replace for <code>#inst</code> in your source files then <code>clojure.instant/read-instant-date</code> or <code>cljs.reader/parse-timestamp</code> are probably the functions you need ;-)</p>
<p>Discuss this post <a href="">here</a>.</p>
<p><i>Published: 2023-06-14</i></p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/clojure.html">clojure</a>
  </span>
  
  <span class="tag">
    <a href="tags/date-time.html">date-time</a>
  </span>
  
  </i>
</p>


</div>
<div>
<h1>
  
  <a href="logging-data.html">
  
  Log data, not strings - with SLF4J
  
  </a>
  
</h1>
<p>A recent release of the popular Java logging abstraction SLF4J has a new API enabling <a href='https://stackify.com/what-is-structured-logging-and-why-developers-need-it/'>structured logging</a>. New Clojure logging macros using this, e.g. <code>&#40;log/info &quot;request-for-help&quot; {&quot;priority&quot; &quot;high&quot;}&#41;</code> are available as <a href='https://github.com/henryw374/slf4clj'>slf4clj</a>.</p><h1>Why Log data?</h1><p>A couple of years ago I made a survey of all the logging libraries one might use from Clojure. The majority of contenders (<a href='https://github.com/clojure/tools.logging'>clojure.tools.logging</a> foremost among them) I ruled out fairly early because they only log strings, not data.</p><p>To explain this limitation, in all logging frameworks you can format messages as json or something and get <code>{level: &quot;INFO&quot;, message &quot;Commissioner Gordon called because Gotham city is under attack from the Joker&quot;}</code>. Whilst useful, what is more queryable is to log arbitrary data (key value pairs) and have that data passed as-is to appenders, which might serialise to json, or write to a database. An equivalent message formatted as JSON might be <code>{level: &quot;INFO&quot;, message-type: &quot;request for help&quot;, urgency: &quot;high&quot;, caller: &quot;Commissioner Gordon&quot;, foe: &quot;Joker&quot;, target:&quot;Gotham&quot; }</code>. Assuming you're not still shelling into boxes and grepping log files, IMO <a href='https://stackify.com/what-is-structured-logging-and-why-developers-need-it/'>structured log data</a> is something you can't go back from.</p><h1>Options for Logging data from Clojure</h1><p>The requirement to log data left two main contenders, <a href='https://github.com/BrunoBonacci/mulog'>MuLog</a> and <a href='https://logging.apache.org/log4j/2.x/'>Log4j2</a>. At the time I decided Log4j2 seemed like  the boring, safe choice. Well, that didn't turn out to be quite right haha! </p><p>As a result of opting for Log4j2, I put some <a href='https://github.com/henryw374/clojure.log4j2'>helper functions in a lib</a> for Clojure users writing log statements against Log4j2. Note: the <a href='https://github.com/henryw374/clojure.log4j2'>README</a> for those contains more detailed comparison of existing Clojure logging libraries.</p><p>Released since I made that review, and created as a result of log4shell is <a href='https://github.com/amperity/dialog'>Amperity's Dialog</a> which is a logging backend for <a href='https://www.slf4j.org/'>slf4j</a>(1.x, string based) - the de facto Java logging facade. Dialog also provides a <a href='https://github.com/amperity/dialog/blob/main/src/clojure/dialog/logger.clj'>Logging API based on logging strings</a> or suggests you use clojure.tools.logging (strings again).</p><h1>Logging from Library Code</h1><p>Log4j2 is a 'logging implementation' or 'backend'. Ideally one would write log statements against a logging abstraction, where log statements get channeled to whatever logging backend is in place. This is especially important when writing library code. Users of e.g. <a href='https://github.com/ptaoussanis/carmine'>Carmine</a> will find logs coming via Timbre whether they like it or not. </p><p>Looking at the options here, assuming we want to log data ofc, MuLog might be a choice. It has be made to plug into an <a href='https://gitlab.com/nonseldiha/slf4j-mulog'>slf4j 1.x backend</a>, so surely can be made to plug into other things.</p><p>The most obvious choice though is <a href='https://www.slf4j.org/'>SLF4J</a>, apparently <a href='https://en.wikipedia.org/wiki/SLF4J'>the most popular Java library of any kind</a>. The 1.x version of this has been around for a long time and as you'd expect from an API dating from the noughties it only logs strings. With the 2.0 release, that has changed.</p><h1>Logging data with Slf4j</h1><p>Enter slf4j 2.0 - which was released toward the end of 2022. The 2.0 version of this popular logging facade newly includes an <a href='https://www.slf4j.org/manual.html#fluent'>API for logging data</a>, whilst remaining backwards compatible with the 1.x API.</p><p>The fluent API contains the <code>addKeyValue&#40;String key, Object value&#41;</code> method for structured logging. It's up to implementations as to what to do with the structured data. They may merge it to the <a href='https://www.slf4j.org/api/org/slf4j/MDC.html'>MDC</a> for that message for example as Log4j2-slf4j bridge does. The MDC is a map of String->String though, which is a problem if the value happens to be anything other than a string.</p><p>It is straightforward to use from Clojure as-is, but there are some convenience macros released as a new library <a href='https://github.com/henryw374/slf4clj'>slf4clj</a>. The aim is not to re-create the whole API, just offer some shorthand for the majority of use cases.</p><p>As you'd expect there are macros for <code>debug</code>, <code>info</code>, <code>warn</code> etc and the args for each are deliberately the same as Clojure's <a href='https://clojuredocs.org/clojure.core/ex-info'>ex-info</a>, namely  <code>&#40;&lt;level&gt; msg map&#41;</code> or <code>&#40;&lt;level&gt; msg map cause&#41;</code>.</p><p>Here is an example:</p><pre><code class="lang-clojure">&#40;require '&#91;com.widdindustries.slf4clj.core :as log&#93;&#41;

&#40;log/info &quot;request-for-help&quot; {&quot;urgency&quot; &quot;high&quot;, &quot;caller&quot; &quot;Commissioner Gordon&quot;, &quot;foe&quot; &quot;Joker&quot;, &quot;target&quot; &quot;Gotham&quot;}&#41;
</code></pre><h2>Migration path</h2><p>If you're using clojure.tools.logging, you can keep your existing setup and just start writing slj4j 2.0 logging statements and that will likely 'just work' in that the data will get printed out in some string format according to your pattern config). Separately you can change your logging backend to  something that does more with structured logs than just turning them into strings, like writing them as JSON for example.</p><h1>Logging APIs bundled with the JVM</h1><p>If you're logging from a library it is possible to avoid having any logging dependency by using APIs included with the jvm.</p><p>java.util.logging (JUL) is the one you have most likely heard of. As you might guess though for something created in the early part of this century, it is a string-based logging API. <a href='https://stackoverflow.com/questions/11359187/why-not-use-java-util-logging'>This question on Stackoverflow</a> goes into some details about JUL but in the threads is mention of a newer platform Logging facade called <a href='https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.Logger.html'>System.Logger</a> - which might be interesting but doesn't seem to have gained traction AFAICT.</p><h1>References</h1><ul><li><a href='https://mccue.dev/pages/12-3-22-better-java-logging-2'>Better Java Logging</a></li></ul><h1>Unrelated FYI</h1><p>This is my first blog post since moving to <a href='https://github.com/borkdude/quickblog'>Quickblog</a> - a blogging tool powered by Clojure - thanks Borkdude!</p>
<p>Discuss this post <a href="">here</a>.</p>
<p><i>Published: 2023-02-09</i></p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/clojure.html">clojure</a>
  </span>
  
  </i>
</p>


</div>
<div>
<h1>
  
  <a href="clojurescript-jar-embeds-other-libs.html">
  
  Clojurescript jar embeds some core libraries
  
  </a>
  
</h1>
<p><em>Update:</em> As of mid-2022, Clojurescript has fixed the problems described in this post.</p><p>Why having clojurescript in the classpath may lead to unexpected behaviour</p><p>The <a href='https://mvnrepository.com/artifact/org.clojure/clojurescript/1.11.4'>clojurescript maven artifact</a>  lists compile dependencies which include: data.json, tools.reader and transit-clj and transit-java. </p><p>However the clojurescript jar itself is something like an uberjar: It includes compiled data.json, tools.reader and transit-clj and transit-java namespaces inside itself. That means that although it declares dependencies on those libraries, when you use Clojurescript yourself, those libraries' artifacts are not used at all (despite being on your disk and in the classpath). </p><p>The output of this command shows the dependencies I am referring to:</p><pre><code>clj -Sdeps '{:deps {org.clojure/clojurescript {:mvn/version &quot;1.11.4&quot; } }}' -Stree
</code></pre><p>The effect is that if you want to use a different version of one of those libraries  compared to the one Clojurescript was compiled with, you can't. Well, you can't with the regular clojurescript artifact, you can use the non-aot version: <code>org.clojure/clojurescript$slim {:mvn/version “1.11.4”}</code>.</p><p>This was not an issue for a long time because those libraries didn't change. Now e.g. clojure.data.json has changed, hence why I hit the problem. </p><p>A handy technique I usually use to answer the question 'where on the classpath is namespace x.y.z getting loaded  from?' is to call <code>io/resource</code> on it. Doing that with data.json and Clojurescript in the classpath  gives result as follows: </p><pre><code class="lang-clojure"> &#40;clojure.java.io/resource &quot;clojure/data/json.clj&quot;&#41;
 
 =&gt; &quot;.../.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj&quot;&#93;
</code></pre><p>which is the wrong answer! I still don't understand why io/resource shows the file there, whereas calling <code>require</code> on that ns returns the one embedded in Clojurescript.</p><p>One might ask why I would be using Clojurescript and clojure.data.json together in the same jvm.  Well, in my case, in development I tend to have my server and client dependencies combined, so  I run cljs compile and server side stuff in one vm. When deploying and testing, I separate them  (meaning Clojurescript jar is only on the classpath when cljs source is being compiled). It is possible to run separate server and cljs jvm's  locally of course, but that then means I can't have a single .nrepl.edn file for example. There could be  other reasons for using these 2 together though, writing data-reader functions that use json possibly.<br /></p><p>I raised this on clojure slack and now Clojurescript's maintainers are aware, so hopefully this gets fixed. </p><p>A fix is likely to involve <code>shading</code>. This is where a library wants to use a fixed version  of another library, so it copies the sources of that library into itself, but changes  the namespaces/packages of the source library to be something different, and specific to itself.</p><p>My thanks go to Alex Miller for explaining this.<br />  </p>
<p>Discuss this post <a href="">here</a>.</p>
<p><i>Published: 2022-02-09</i></p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/clojure.html">clojure</a>
  </span>
  
  </i>
</p>


</div>

      
      <div style="margin-bottom: 20px; float: right;">
        <a class="page-link" href="archive.html">Archive</a>
      </div>
      
    </div>
  </body>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2X3CK9F000"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2X3CK9F000');
</script>
</html>
