<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry Widd's Blog</title>
  <link href="https://widdindustries.com/blog/atom.xml" rel="self"/>
  <link href="https://widdindustries.com/blog"/>
  <updated>2023-01-01T16:54:44+00:00</updated>
  <id>https://widdindustries.com/blog</id>
  <author>
    <name>Quick Blogger</name>
  </author>
  <entry>
    <id>https://widdindustries.com/blog/clojurescript-jar-embeds-other-libs.html</id>
    <link href="https://widdindustries.com/blog/clojurescript-jar-embeds-other-libs.html"/>
    <title>Clojurescript jar embeds some core libraries</title>
    <updated>2022-02-09T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p><em>Update:</em> As of mid-2022, Clojurescript has fixed the problems described in this post.</p><p>Why having clojurescript in the classpath may lead to unexpected behaviour</p><p>The <a href='https://mvnrepository.com/artifact/org.clojure/clojurescript/1.11.4'>clojurescript maven artifact</a>  lists compile dependencies which include: data.json, tools.reader and transit-clj and transit-java. </p><p>However the clojurescript jar itself is something like an uberjar: It includes compiled data.json, tools.reader and transit-clj and transit-java namespaces inside itself. That means that although it declares dependencies on those libraries, when you use Clojurescript yourself, those libraries' artifacts are not used at all (despite being on your disk and in the classpath). </p><p>The output of this command shows the dependencies I am referring to:</p><pre><code>clj -Sdeps '{:deps {org.clojure/clojurescript {:mvn/version &quot;1.11.4&quot; } }}' -Stree
</code></pre><p>The effect is that if you want to use a different version of one of those libraries  compared to the one Clojurescript was compiled with, you can't. Well, you can't with the regular clojurescript artifact, you can use the non-aot version: <code>org.clojure/clojurescript$slim {:mvn/version “1.11.4”}</code>.</p><p>This was not an issue for a long time because those libraries didn't change. Now e.g. clojure.data.json has changed, hence why I hit the problem. </p><p>A handy technique I usually use to answer the question 'where on the classpath is namespace x.y.z getting loaded  from?' is to call <code>io/resource</code> on it. Doing that with data.json and Clojurescript in the classpath  gives result as follows: </p><pre><code class="lang-clojure"> &#40;clojure.java.io/resource &quot;clojure/data/json.clj&quot;&#41;
 
 =&gt; &quot;.../.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj&quot;&#93;
</code></pre><p>which is the wrong answer! I still don't understand why io/resource shows the file there, whereas calling <code>require</code> on that ns returns the one embedded in Clojurescript.</p><p>One might ask why I would be using Clojurescript and clojure.data.json together in the same jvm.  Well, in my case, in development I tend to have my server and client dependencies combined, so  I run cljs compile and server side stuff in one vm. When deploying and testing, I separate them  (meaning Clojurescript jar is only on the classpath when cljs source is being compiled). It is possible to run separate server and cljs jvm's  locally of course, but that then means I can't have a single .nrepl.edn file for example. There could be  other reasons for using these 2 together though, writing data-reader functions that use json possibly.<br /></p><p>I raised this on clojure slack and now Clojurescript's maintainers are aware, so hopefully this gets fixed. </p><p>A fix is likely to involve <code>shading</code>. This is where a library wants to use a fixed version  of another library, so it copies the sources of that library into itself, but changes  the namespaces/packages of the source library to be something different, and specific to itself.</p><p>My thanks go to Alex Miller for explaining this.<br />  </p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/async-meet-laziness.html</id>
    <link href="https://widdindustries.com/blog/async-meet-laziness.html"/>
    <title>you Promise to be Lazy?</title>
    <updated>2022-02-03T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>Combining Java's promises with Clojure's laziness yields some interesting behaviour</p><p>Consider:</p><pre><code class="lang-clojure">
&#40;doseq &#91;x &#40;range 1000000&#41;&#93;&#41;

</code></pre><p>Since <code>range</code> returns a lazy sequence and <code>doseq</code> does not retain the head of the sequence, there will only be one element of the sequence realized at every step of the <code>doseq</code>.</p><p>Now let's split the creation and consumption of the lazy sequence over chained promises.  I am using <a href='https://github.com/funcool/promesa'>the promesa library</a>, which on the jvm is a thin wrapper over java.util.concurrent#CompletableFuture.</p><pre><code class="lang-clojure">
&#40;-&gt; &#40;p/resolved &#40;range 1000000&#41;&#41;
    &#40;p/then &#40;fn &#91;xs&#93;
              &#40;doseq &#91;x xs&#93;&#41;&#41;&#41;&#41;

</code></pre><p>It looks like it should be just as lazy. Nowhere is the code above retaining a reference to  the head of the sequence - and yet it is! </p><p>The <code>then</code> promise internally has a reference to the preceding promise and that promise has a reference to its result - the head of the sequence. When the first promise returns, the sequence is unrealized, but as the subsequent <code>then</code> promise consumes the sequence it is realized and the head retained  by the preceding promise!</p><p>What happens if there is a longer chain of promises? A promise executing in a chain only has reference to the preceding one. The preceding one has lost its reference to the  next one upstream of itself, so in a chain just the current and immediately preceding one are not  gc-able. </p><p>So? Well imagine you are streaming results out of a db for example - that might be  modelled as a lazy seq, which is consumed through e.g. doseq and written out to a  stream. Sounds like a nice memory-friendly solution, but if the db request results in a  promise it might seem natural to keep chaining that result on. </p><h1>Further thoughts</h1><p>Does this apply to </p><ul><li>js promises? I would imagine so</li><li>core.async channels? I would guess not</li></ul><p>I haven't investigated.</p><p>Related to this topic is <a href='https://stuartsierra.com/2015/08/25/clojure-donts-lazy-effects'>Stuart Sierra's Lazy Effects</a> post, in which he says never mix laziness and side-effects. Good advice I would say.</p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/tick-is-out-of-alpha.html</id>
    <link href="https://widdindustries.com/blog/tick-is-out-of-alpha.html"/>
    <title>Tick is out of alpha!</title>
    <updated>2021-09-28T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p><a href='https://github.com/juxt/tick'>Tick</a> provides a powerful, cross-platform date-time API way beyond what  java.time offers. It is implemented on top of <a href='https://github.com/henryw374/cljc.java-time'>cljc.java-time</a> which again is cross-platform as has exactly the same API as java.time.</p><p>For years now, the API has been <code>alpha</code>, by which we mean "Ready to use with the caveat that the API might still  undergo minor changes". With the current release, the API of tick has been split into </p><ul><li>a <code>tick.core</code> namespace, which will have no breaking changes in future releases</li><li>a <code>tick.alpha.interval</code> namespace, which contains just the functions pertaining to Allen's intervalcalculus. As its name suggests, this is still alpha. Apologies if the title of this post is misleading, I didn't want to stuff it with caveats.</li></ul><p>There are plans to revisit the interval functions and documentation and some changes to the API may arise from that work.</p><p>If you are upgrading from an earlier (0.4* version), here is what needs to change:</p><ul><li>replace all <code>tick.alpha.api</code> requires with <code>tick.core</code></li><li>If you used the <code>+</code> or <code>-</code> functions, note that these now only work where the arguments are allPeriods or all Durations. To move a time by an amount, use <code>&gt;&gt;</code> or <code>&lt;&lt;</code> instead, keeping the arguments the same. This change was made to make +/- analagous to clojure.core's +/-, where the arguments are commutative andassociative. It also means there is now just one way to 'move' a time in Tick.</li><li>The <code>parse</code> function has now been removed from the API. Instead, choose the appropriate function for theformat of the string you need to parse, e.g. <code>&#40;t/date &quot;2020-02-02&quot;&#41;</code>. The parse function was slow by definition, as it tried to find an appropriate entity matching the string it was given. It also meant that iffor some reason the string you passed it was not in the format you expected, it might be parsed intoa different date-time entity than you expected, which is never going to be good.</li><li>The compiler will report about any other functions not found in tick.core. Those will be the interval ones,so adding a require of <code>tick.alpha.interval</code> will address those.</li></ul><p>That's it. </p><p>Making breaking changes may be frowned on in the Clojure community, but they seem entirely reasonable to me in this case because:</p><ul><li>The api always had an <code>alpha</code> warning.</li><li>There is no obligation to upgrade. Tick is an <code>end-user</code> kind of library: I doubt any other libsdepend on it, so dependency hell is not an issue.</li></ul><p>One last thing, the current version is <code>RC</code>, release candidate. IOW please kick the tyres and let us know of any problems. We have already been using it in production for a while, with no issues. After a  period of a couple of months, we'll remove the RC label.<br /></p> ]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/clojurescript-datetime-lib-comparison.html</id>
    <link href="https://widdindustries.com/blog/clojurescript-datetime-lib-comparison.html"/>
    <title>Performance comparison of Clojurescript date/time libraries</title>
    <updated>2021-08-16T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>In this post I am going to compare the performance of two Clojurescript date-time libraries, in the context of  a typical single-page web application.</p><h1>The Libraries</h1><h2>Cljc.java-time</h2><p><a href='https://github.com/henryw374/cljc.java-time'>cljc.java-time</a> (disclaimer: authored by myself) has the same API as java.time,  but targets both Clojure and Clojurescript.  It is implemented on top of a pure Javascript implementation of <code>java.time</code> called JS-Joda.</p><p>It is also the underlying library for Juxt's <a href='https://github.com/juxt/tick'>Tick</a>   which provides a powerful date-time API beyond what java.time offers. In this blog post I am considering cljc.java-time  instead of Tick, because I expect a larger proportion of readers will already have some familiarity   with java.time's API. </p><h2>Deja-fu</h2><p><a href='https://github.com/lambdaisland/deja-fu'>Deja-fu</a> is a new Clojurescript date/time library  positioning itself as being for "applications where dealing with time is not enough of their core business to justify these large dependencies". The 'large dependendencies' being referred to there are those required by <code>cljc.java-time</code>.</p><p>Deja-Fu's API offers a pure-cljs <code>Time</code> entity and otherwise wraps the platform js/Date objects,  via the goog.date API.</p><p>The long established <a href='https://github.com/andrewmcveigh/cljs-time'>Cljs-time</a> is similar to Deja-fu in that it also wraps the goog.date API. I'm not measuring that here, but I would expect to see similar results.</p><h1>Motivation</h1><p>Deja-fu appears to offer a trade off between a "good-enough date/time library, that's very lightweight"  vs a "complete date/time library that's heavier". My feeling is that cljc.java-time is not meaningfully heavier and  that <code>light</code> date/time libraries are often heavy on developer time, bugs or both. </p><p>In my own experience of developing Clojurescript web  applications with cljc.java-time, I haven't see any performance problems - I'm already using Clojurescript and React so there's already a significant build size, but given my users' devices and  network connections (reasonably up to date, but nothing special) the applications seem to perform very well.</p><p>I once did <a href='https://www.youtube.com/watch?v=UFuL-ZDoB2U'>a talk</a>  introducing cljc.java-time and related libraries, but only briefly talked about build size - should I have said it   was only suitable if date/time was so core to the app that "large dependencies" could be justified ? FYI Build size <a href='https://github.com/juxt/tick/blob/master/docs/cljs.adoc'>is already discussed</a> in the documentation. </p><p>Over the years since I released cljc.java-time I've come across (and generally ignored) the <code>too large/heavy</code> PoV a couple of times,  but Deja-fu's recent appearance has prompted me to put it head to head with cljc.java-time in an experiment.  </p><h1>The Experiment</h1><p>For my experiment I have written two versions of a basic Clojurescript web application. </p><p>People are using Clojurescript in various places, including highly constrained environments like microcontrollers, but based on what  I see the React webapp is what the majority are targeting and the use-case for which I would like people to have some more help when choosing a date/time API. </p><p>These apps have been deployed on the web so that tools such as <a href='https://developers.google.com/speed/pagespeed/insights/'>PageSpeed</a> can be used to test them. They are hosted on Firebase, but just because I already had a dummy project set up there. They don't use any Firebase APIs.</p><p><table>   <thead>     <tr>       <th>Version</th>       <th>TTI  (mobile)</th>       <th>TTI (desktop)</th>     </tr>   </thead>   <tbody>     <tr>       <td><a href="https://friendly-eats-demo-e71b7.web.app/js-date.html">Deja-fu version</a></td>       <td>2.1s</td>       <td>0.6s</td>     </tr>     <tr>       <td><a href="https://friendly-eats-demo-e71b7.web.app/java-time.html">cljc.java-time version</a></td>       <td>2.2s</td>       <td>0.7s</td>     </tr>   </tbody> </table></p><p> TTI (time-to-interactive) shown in the table above was taken from PageSpeed analysis. The cljc.java-time version is slower   according to that analysis, but not in any meaningful way.   </p><p>Consider that (the Javascript behind) cljc.java-time and React are fixed-size costs though. Being a small demo app, they   are disproportionately big. If application code grows over time with features their  relative size will reduce ofc.</p><p>The memory usage for both apps was roughly the same, as observed in a recent version of Chrome. Deja-fu is using js/Date objects, which have a single number field (representing an offset from the unix epoch). The cljc.java-time version is using  LocalDate objects which  have 3 numeric fields: year, month and day. Having the additional two fields could become significant if a large  amount of date objects need to live in memory.  </p><p>What about download size? Well, let's imagine that every time a user visits these apps, the Clojurescript code has  been changed and released, so cannot be retrieved from cache and must be re-downloaded. It will only take 2-3 visits before the total amount of data downloaded across those visits is greater  in the Deja-fu version. This is because in the cljc.java-time version, the underlying data/time lib is downloaded separately,  and so is cacheable. This is very simple to set up and I would put it in the 'no brainer' category if data allowance is a significant issue for an app. </p><p>Maybe we could modularize the Deja-fu version so the library code can be cached over visits,  but my main point here is YMMV.</p><p>Are there more metrics that we should look at here? Please suggest anything you think is significant.</p><h1>The code</h1><p>Shown below is the code that is different between the two versions.</p><p>Two functions are required</p><ul><li><code>tomorrow</code> returns tomorrow's date. This is needed so the date picker will only let userspick future dates</li><li><code>interval-calc</code> works out the number of days between 2 dates.</li></ul><p>The <a href='https://github.com/henryw374/cljs-date-lib-comparison'>source code for these can be found here</a>.</p><h2>Deja-fu</h2><pre><code class="lang-clojure">
&#40;ns time-lib-comparison.js-date
  &#40;:require &#91;lambdaisland.deja-fu :as deja-fu&#93;
            &#91;time-lib-comparison.app-main :as app&#93;&#41;&#41;

&#40;def millis-per-day &#40;&#42; 1000 60 60 24&#41;&#41;

&#40;defn interval-calc &#91;event-date&#93;
  &#40;let &#91;now &#40;deja-fu/local-date&#41;

        event-date &#40;deja-fu/parse-local-date event-date&#41;

        interval-millis &#40;- &#40;deja-fu/epoch-ms event-date&#41;

                          &#40;deja-fu/epoch-ms now&#41;&#41;&#93;
    &#40;/ interval-millis millis-per-day&#41;&#41;&#41;

&#40;defn tomorrow &#91;&#93;
  &#40;-&gt; &#40;deja-fu/local-date&#41;
      &#40;update :days inc&#41;&#41;&#41;

</code></pre><h3>cljc.java-time</h3><pre><code class="lang-clojure">
&#40;ns time-lib-comparison.java-time
  &#40;:require &#91;cljc.java-time.local-date :as date&#93;
            &#91;cljc.java-time.temporal.chrono-unit :as cu&#93;
            &#91;time-lib-comparison.app-main :as app&#93;&#41;&#41;

&#40;defn interval-calc &#91;event-date&#93;
  &#40;-&gt; cu/days &#40;cu/between &#40;date/now&#41; &#40;date/parse event-date&#41;&#41;&#41;&#41;

&#40;defn tomorrow &#91;&#93;
  &#40;-&gt; &#40;date/now&#41;
      &#40;date/plus-days 1&#41;&#41;&#41;

</code></pre><h1>And now, a twist</h1><p>The libraries have been weighed up against each other performance-wise, but of course that is only one part of the story. </p><p>Did you notice any bugs in the Deja-fu version? Go back and look if you want, I will reveal the issues in the next sentence.</p><p>Firstly, the Deja-fu version is expecting that there are 24 hours in a day - and generally that's right, except when crossing  a DST boundary. The other issue is in the <code>tomorrow</code> function of the Deja-fu version. It returns a date, but not tomorrow's.<br /></p><p>If you already know java.time, then it's not just different method signatures you'd have to deal with in using Deja-fu, but actual semantics. For example, if you 'add' a month to the  31st January, what happens? A decision had to be made by the API authors, and that decision was made differently.</p><p>I did think about putting bugs in the cljc.java-time version too but they looked like obvious typos, like <code>&#40;plusDays 2&#41;</code> for <code>tomorrow</code>.</p><h2>Is this a fair test?</h2><p>I have chosen some requirements for the app where in the Deja-fu version I need to use the much  maligned js/Date API. If you knew you'd be going down that road from the start, you might think twice about choosing a  <code>lightweight</code> date/time library, but generally we can't be sure what requirements will come our way. </p><p>Also, if the app needed to do custom parsing and formatting from/to strings, for the cljc.java-time version I'd need to bring in a JSJoda addon,  which takes TTI up to 2.5 seconds on mobile, whereas with the Deja-fu version TTI would be the same.</p><h1>Looking to the future</h1><p><a href='https://github.com/henryw374/tempo'>Tempo</a> is my work-in-progress attempt to make a date-time API  with the common parts  of java.time and the new platform API for Javascript called <code>Temporal</code> (to be available in browsers sometime soon,  possibly this year).</p><p>The fact that Temporal is a platform API is the big reason of course.</p><p>My feeling is there is sufficiently large overlap between Java and Javascript's platform date-time APIs to make a useful  library that will suit cross-platform  <a href='https://github.com/metosin/malli/issues/49'>library authors needing some basic date/time functionality such as Malli</a> and  perhaps also as a basis for a 'lite' version of the Tick library. </p><p>Will cljc.java-time become irrelevant in a Tempo future? I don't think so because I think for many it will continue to be a solid,  familiar choice that comes with minimal overhead and maximum stackoverflow-ability. <a href='http://www.menodata.de/blog/2013/12/02/die-neue-zeitbibliothek-von-java8-eine-rezension/#more-174'>Not everyone loves java.time</a> but it's usually good enough.</p><h1>Conclusion</h1><p>The main take-away I would hope readers get from this is that that cljc.java-time should not be dismissed out of hand for some common use cases, just  as we don't generally pick C over Clojure because an equivalent program might be less resource intensive.</p><p>There may well be Clojurescript applications where cljc.java-time would be inappropriate, but my feeling is  for typical Clojurescript web applications it's not an issue.  </p><p>I'd definitely be interested to hear about your opinions on this and Clojurescript build sizes in general. What are you shipping? How did you make decisions  about what build size was acceptable (including the use of Clojurescript itself)?</p><p>Feel free to use <a href='https://clojureverse.org/t/performance-comparison-of-clojurescript-date-time-libraries/8046'>this thread on Clojureverse</a> to comment. </p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/clojurescript-jsinterop.html</id>
    <link href="https://widdindustries.com/blog/clojurescript-jsinterop.html"/>
    <title>Accessing Javascript objects from Clojurescript</title>
    <updated>2021-03-01T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>There are choices as to how you do Clojurescript <code>interop</code> ( accessing a Javascript object's methods and properties) and that's what I'm going to look into here.</p><p>IMHO Clojurescript is somewhat lacking when it comes to official documentation, hence this blog post, and the need to quote from twitter:</p><p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">In concrete terms, sounds like<br>✓ (.-length &quot;abc&quot;)<br>X (.-length <a href="https://twitter.com/hashtag/js?src=hash&amp;ref_src=twsrc%5Etfw">#js</a> {:length 3})<br>✓ (goog.object/get <a href="https://twitter.com/hashtag/js?src=hash&amp;ref_src=twsrc%5Etfw">#js</a> {:length 3} &quot;length&quot;)</p>&mdash; Mike Fikes (@mfikes) <a href="https://twitter.com/mfikes/status/882585745424338944?ref_src=twsrc%5Etfw">July 5, 2017</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p><p>I'm going to look into the tradeoffs of what David and Mike say there.</p><p>Firstly, I'll try to make a clear distinction between JS data vs API: A data object is  any object you could round-trip through JSON/stringify => JSON/parse. An object that may appear   to be a data object because it only contains properties (ie no methods), may not be because those properties might be <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get'>getter</a>s or setters (e.g. the <code>length</code> property of String "foo" referred to in the twitter post is a <code>getter</code>).</p><p>If an object came to your program via a call made to a JS library or API, it's most likely not a data object unless the library documentation explicitly says so. </p><p>Secondly, be aware that when doing advanced compilation with Clojurescript, the compiler will change all the variable and function names in your program to reduce overall build size. This works automatically for regular Clojurescript code, but when doing <code>interop</code> extra configuration is sometimes required which takes the form of type hints in the code or externs files.</p><p>Ok, with those two points in mind, let's proceed.</p><h1>Dot-access vs goog.object/get</h1><p>I find the <code>&#40;.-length &quot;foo&quot;&#41;</code> item in Mike's list interesting. According to the advice, we would also choose <code>&#40;.-length #js&#91;&#93;&#41;</code> when using the API of Javascript arrays.</p><p>Consider the alternative: </p><pre><code class="lang-clojure">&#40;goog.object/get #js&#91;&#93; &quot;length&quot;&#41;

; =&gt; returns 0
</code></pre><p>This demonstrates it is possible to use <code>goog.object</code> to access API properties. So, we have what appears to be just a stylistic choice between this and <code>&#40;.-length #js&#91;&#93;&#41;</code>. </p><p>Why choose either one? </p><p>Firstly, note that <code>length</code> is a special-case property name: <code>length</code> never needs type hinting, because  the names of properties that are part of the in-built JS or DOM API objects are always specifically left alone by the Clojurescript compiler. That works whether we are referring to the <code>length</code> property of a Javascript array, or the <code>length</code> property of some JS object you defined yourself: however it appears,  if the property name appears in the core JS API, it is left untouched.</p><p>So to be more general, let's consider a property name that does not appear in the standard JS API, <code>xxx</code>:</p><p>So, IOW, working with the API of foo, we would have a choice of: <code>&#40;.-xxx foo&#41;</code> vs <code>&#40;goog.object/get foo &quot;xxx&quot;&#41;</code> </p><p>The goog.object one will survive advanced compilation (meaning it is compiled to <code>foo.xxx</code> or equivalent),  whereas the dot-access version will need a type hint (as in <code>&#40;.-xxx &#94;js foo&#41;</code>) to avoid <code>xxx</code>  being renamed under advanced compilation. </p><p>So +1 for the goog.obj approach so far because less config is required.</p><p>However, in working with the API of some JS object, it's quite common to both access properties/getters and call methods:</p><pre><code class="lang-clojure">&#40;let &#91;foo &#94;js &#40;some-fn&#41;

      bar-prop &#40;.-bar foo&#41;&#93;
    &#40;.methodFoo foo &#40;inc bar-prop&#41;&#41;&#41;
</code></pre><p>We could have accessed <code>bar</code> with <code>goog.object/get</code>, but this code is being consistent in using only dot-access for the API of <code>foo</code>. We could also have accessed <code>methodFoo</code> with  goog.object/get (and then invoked it), but that would look pretty ugly.</p><p>So, in sticking to David Nolen's advice <code>dot access only for APIs</code> this code makes a clear statement  that it is working with API of <code>foo</code>, not a data object called <code>foo</code> - regardless of whether it is methods, properties or both, that we need to  use. This comes as the cost of having to remember to put type hints in. </p><p>If we forgot to type hint <code>foo</code> in that example, the properties <code>bar</code> and <code>methodFoo</code> would be renamed and  the code would fail at runtime. For this reason, if you use advanced compilation, you must test your code  having advanced compiled it first. Doing advanced compilation is slow, do during development I generally avoid it, but continuous integration tests and beyond should use the same compilation level as production.</p><p>If Google Closure did become able to optimise regular JS code (ie code that is now <code>foreign</code>),  then code that is using strings to access JS APIs (<code>goog.object/get</code> & equivalent libraries ) would then be broken.</p><p>I've come to think type hints aren't so bad, because now <a href='https://code.thheller.com/blog/shadow-cljs/2017/11/06/improved-externs-inference.html'>type hints are documented</a> I think it's easy enough to understand you just need to add <code>&#94;js</code> when you first see the js object in scope.</p><h1>Conclusion</h1><p>I prefer dotted access for API access because it is stylistically distinct from data access, which makes my code easier to  understand. It also future-proofs it against improvements in the compiler. This comes at a cost of having to add type hints, but that cost is low and is mitigated by running tests under advanced compilation.</p><h1>More Choices</h1> <p>There are libraries that have been created for working with JS APIs such as <a href='https://github.com/applied-science/js-interop'>js-interop</a>. These aim to provide a trade-off between dotted access and goog.object/get in that type hints are not required, but aim to provide a nice, straighforward syntax. Personally I don't use these libraries because I think regular dotted access is good enough.</p><p>If working with JS data, ie not API, then an alternative to <code>goog.object</code> is <a href='https://github.com/mfikes/cljs-bean'>Cljs Bean</a>  </p><h1>Final Thoughts</h1><p>So, now that's all cleared up, which <a href='https://cljs.github.io/api/syntax/dot'>dot-access</a> is preferred, <code>a.b.c</code> or <code>&#40;.. a -b -c&#41;</code> ...?</p><p>Dot access in the style of <code>a.b.c</code> does have <a href='https://clojure.atlassian.net/browse/CLJS-3315'>an issue</a>, which is a shame (until fixed) because to me that seems pretty tasteful.</p><p>Would you like to see official documentation on this topic?  If so, raise an issue <a href='https://github.com/clojure/clojurescript-site/issues'>here</a></p><p>Thanks to Thomas Heller for providing the point about future-proofing.  </p>                                                        <br />]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/clojurescript-firebase-simple.html</id>
    <link href="https://widdindustries.com/blog/clojurescript-firebase-simple.html"/>
    <title>Wrapper-free Firebase with Clojurescript's Re-Frame</title>
    <updated>2021-02-19T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>I recently made my first crud-style hobby app with Firebase and  I wanted to write it in Clojurescript.... of course ;-)</p><p>Looking around the internet for pointers, I found some Clojurescript-Firebase wrapper libraries I am  not too keen on, and no great demo apps either... so I created <a href='https://github.com/henryw374/firerebase-clojurescript-todo-list'>my own demo 'todo-list' app</a></p><p>The README there contains a small list of instructions that should get you up and running quickly and deploying the  app to the internet in no time. Then you can spend many happy hours building from there.</p><h1>Firebase Wrappers?</h1><p><a href='https://lmgtfy.app/?q=clojurescript+firebase'>Googling for 'Clojurescript Firebase'</a> I found a couple  of 'wrapper libraries', <a href='https://github.com/deg/re-frame-firebase'>re-frame-firebase</a>  and <a href='https://github.com/fbielejec/cljs-firebase-client'>cljs-firebase-client</a>. </p><p>I've <a href='https://widdindustries.com/why-not-interop/'>written before</a> about wrappers - tl;dr approach with caution. </p><p>There are obvious issues with the wrappers mentioned above: </p><ul><li>They're made to work for now-old versions of Firebase.</li><li>They tie in to specifics like shadow or cljsjs</li><li>They introduce some new stuff I have to understand</li><li>... and ofc they don't have the glitzy docs and tutorials that the Firebase site does.</li></ul><p>The <a href='https://github.com/fbielejec/cljs-firebase-client'>cljs-firebase-client</a> lib is billed as a library, but it looks very unfinished. It might have some snippets you  could borrow, especially if you want to use Shadow.</p><p>The <a href='https://github.com/deg/re-frame-firebase'>re-frame-firebase</a> lib has an api to cover pretty  much all of Firebase I think, so there's a lot of code. It also has some dependencies I'm not sure  I want:</p><ul><li>Re-frame wrapper lib (iron)</li><li>clojure.spec</li></ul><p>and of most concern is way state from Firebase (auth-state, database contents) is stored in  the Re-frame 'app-db'. The authors note this is <a href='https://github.com/deg/re-frame-firebase/blob/ed5eabb6caa404af3395e3c97cb59a7c4d302c6b/src/com/degel/re_frame_firebase/database.cljs#L56'>a potential bug</a> and indeed it is. It's also not necessary, as I'll demonstrate below. <br /></p><h1>Wrapper-free Firebase</h1><p>The Firebase docs are great and got me a non-cljs 'hello, world' very easily. Could I bring in  Clojurescript without introducing much new complexity? Well, I've attempted that in the todo app - see what you think.</p><p>One thing you'll notice with Firebase is that you pick and choose the APIs you want to include. For example  if you want to use a database, you get a choice of two different ones. This is nice and in my todo-list app, I use just 'auth' and 'realtime database', so that's all you'll see any code for. </p><h2>Auth with Re-Frame</h2><p>The todo app requires users to authenticate with a Google login. </p><p>Firebase has a simple api to trigger this. The interesting bit from a Clojurescript point of view is listening for the user information once they have successfully authenticated:</p><pre><code class="lang-clojure">&#40;defn user-info &#91;&#93;
  &#40;let &#91;auth-state &#40;r/atom nil&#41; &#93;
    &#40;.onAuthStateChanged &#40;auth&#41;
      &#40;fn &#91;user&#93;
           &#40;reset! auth-state &#40;user-&gt;data user&#41;&#41;&#41;&#41;
    auth-state&#41;&#41;
</code></pre><p>This function that returns a Reagent atom that will contain user information when it is available. We can call this function any time and use the result in a reactive context, such as in a Reagent component - It doesn't matter if the user has already authenticated or not at the time the function is invoked. </p><p>There's no need to store the user data in the app-db. Doing so would leave us with more state to  manage, clean up and so on. There's no Re-frame involvement required, but we could tie this  function into a re-frame subscription as I'll demonstrate next.</p><h2>'Realtime database' with Re-Frame</h2><p>Pushing data to the database is pretty straightforward and well documented and you can imagine how those calls might be wrapped up as <a href='https://day8.github.io/re-frame/api-builtin-effects/#what-are-effects'>Re-Frame 'effects'</a>, as they have been in the 'todo' demo app.</p><p>Listening for data with Re-frame is a bit more interesting though. Similar to the atom that contained the auth data above, we can have a function to return a Reaction (same thing as reactive atom effectively)  containing the current value at some path in the Firebase database:</p><pre><code class="lang-clojure">&#40;defn on-value &#91;{:keys &#91;path&#93;}&#93;
  &#40;let &#91;ref &#94;js &#40;db/fb-ref path&#41;
        val &#40;r/atom nil&#41;
        callback &#40;fn &#91;x&#93; &#40;reset! val &#40;-&gt;clj x&#41;&#41;&#41;&#93;
    &#40;.on ref &quot;value&quot; callback&#41;
    &#40;reagent.atom/make-reaction
      &#40;fn &#91;&#93; @val&#41;
      :on-dispose #&#40;do &#40;.off ref &quot;value&quot; callback&#41;&#41;&#41;&#41;&#41;
</code></pre><p>The 'Reaction' object returned from this function will be updated with the current value whenever  it changes - nice! Now, if we want to use that as part of a Re-frame subscription, we can call it  from a <a href='https://github.com/day8/re-frame/blob/2965ffeda9b8f3b687e2c3e0ba9a62e7fe64c0bb/src/re_frame/core.cljc#L201'>Signal function</a></p><pre><code class="lang-clojure">&#40;rf/reg-sub ::foo 
  &#40;fn this-is-the-signal-function &#91;&#91;&#95; args&#93;&#93;
    {:bar &#40;on-value args&#41;}&#41;
  &#40;fn this-is-compute-function &#91;{:keys &#91;bar&#93;}&#93;
     ;... do some further transform with 'bar' value from db
  &#41;&#41;
</code></pre><p>If you haven't used signal functions before, it's well worth a read of the <a href='https://github.com/day8/re-frame/blob/2965ffeda9b8f3b687e2c3e0ba9a62e7fe64c0bb/src/re_frame/core.cljc#L201'>hefty docstring</a>  to understand them. The todo-list app demonstrates this in action.</p><p>So... we can read and write data, and the Re-frame 'app-db' is nowhere in sight. I haven't got  anything against the app-db - but I don't want to stuff in there unnecessarily - because for any  data in there, you have to understand what effects put it there, how it's lifecycle is managed and so on. I might write more about this in a later post.</p><p>Firebase stores the data in the cloud and keeps a local copy of that sync'ed in the <a href='https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage'>browser's store</a> in  case the connection drops. Re-frame handles doing minimal computation work, de-duping subscriptions etc.  So... let's just lean on all that awesome machinery!</p><p>What about data the user is editing? In the todo app, that is component-local state only when  the user is actually changing it, and is sent off to Firebase via <code>re-frame/dispatch</code> at the appropriate time.</p><p>In fact, in this little example you might see Re-Frame as overkill and just stick with Reagent.</p><p>One last point about the Firebase database - it's json data of course, so it's not going to work to  create Clojure maps with the usual edn goodies like  non-string keys, namespaced keywords & etc. A nice approach to stay in JS/JSON land is to use <a href='https://github.com/mfikes/cljs-bean'>cljs-bean</a> for your data, rather than native  Clojure datastructures.</p><h2>Compile and Deploy</h2> <p>The todo-list README demonstrates doing a build with advanced compilation.   </p><p>The build includes the <code>:infer-externs</code> option, which uses the <code>&#94;js</code> <a href='https://code.thheller.com/blog/shadow-cljs/2017/11/06/improved-externs-inference.html'>tag metadata</a> to let the compiler know to leave the calls to the Firebase APIs as they are.</p><p>Keep these compiler debug opts handy if you do get any problems with the minified build (ie you see error messages in the browser console like 'x.y is not a function'):</p><pre><code class="lang-clojure">&#40;def debug-opts
  {:pseudo-names true
   :pretty-print true
   :source-map true
   }&#41;
</code></pre> <h2>Conclusion</h2><p>Firebase seems pretty nice for a hobby project - and maybe for more serious apps too. Using it with Clojurescript and Re-Frame is straightforward and a natural fit. For example, Firebase <code>onValue</code> lets you listen for the latest value in some part of the database and that is easily hooked into a Re-frame subscription so the view magically updates whenever the database does. Simples!</p><p>Some points of note:</p><ul><li>Firebase-wrapping libraries aren't necessary because you'll learn just the bits you need from firebase docs.</li><li>Avoid putting Firebase state in the Re-Frame app-db. <a href='https://github.com/day8/re-frame/blob/2965ffeda9b8f3b687e2c3e0ba9a62e7fe64c0bb/src/re_frame/core.cljc#L201'>Signal functions</a> will hold state for just as long as necessary.</li><li>No need for externs, <code>&#94;js</code> type hints are all that's required.</li><li>Bundling Firebase libraries via npm or cljsjs is strictly optional.</li><li>Develop the app locally with the Firebase emulator</li><li>Stay JSON-friendly with <a href='https://github.com/mfikes/cljs-bean'>cljs-bean</a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/why-not-interop.html</id>
    <link href="https://widdindustries.com/blog/why-not-interop.html"/>
    <title>Why not Interop with java.time?</title>
    <updated>2021-01-04T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>Using interop syntax with the java.time API is not wrong, but there is an alternative that is superior in every respect - and it just got much better.</p><p>Some in the Clojure community would say that if a Java or JS API is good, then it needn't be  'wrapped' in a library, because plain interop code is idiomatic and any wrapping library might:</p><ul><li>Miss out something of the underlying API (so you likely need to know both anyway)</li><li>Have fewer tests/documentation/community etc</li><li>Introduce some subtle new semantics</li><li>Not keep up with releases of the underlying</li></ul><p>Those concerns all seem reasonable, but consider <a href='https://github.com/henryw374/cljc.java-time'>this java.time wrapper</a>. Every one of the above concerns is addressed: The Clojure API is identical to the underlying Java API (addresses first 3 points) and the underlying API is stable (last point).</p><p>Okaaaay ... but if it's so similar, why use it at all?</p><p>The library's main reason to exist is because it works cross-platform, a huge win on my current projects - but let's leave that aside for the moment and consider the  jvm-only POV.</p><h2>Camel->Kebab wrapping benefits</h2><ul><li>All type hinting is done for you</li><li>comp, apply, juxt and all other clojure.core higher-order fns can now be used rather than anon fn interop: <code>#&#40;.bar %&#41;</code></li><li>In fact, instead of seeing code like <code>#&#40;.isAfter %&#41;</code>, you'll use a properly namespaced clojure function <code>x.y/is-after</code> - much better!</li><li>The Javadoc of the original API will be more readily available via Clojure docstrings (see <a href='https://github.com/henryw374/cljc.java-time/issues/16'>issue</a>)</li></ul><h2>Additional API</h2><ul><li>Predicates, for example <code>&#40;local-date? x&#41;</code></li></ul><p>This could be used for spec definitions for example.</p><h2>Exceptions That Say Something Helpful</h2><p>This is a very recent addition (<a href='https://clojars.org/cljc.java-time'>0.1.12</a> and takes a bit of explaining. In java.time, you have an <code>Instant</code> which is equivalent to a <code>java.util.Date</code> in that it's instances represent <code>the start of a nanosecond on the timeline</code>. Now the tricky thing about Instants is that the only field/data they contain is an offset from the UNIX Epoch (midnight, Jan 1st 1970, UTC). Instants know nothing about years, months, days, hours etc etc. In the lingo, they are not 'calendar-aware', so you cannot add a year to an Instant or ask for it's day of the week. BUT... the API kind of suggests that might be possible. </p><p>Firstly, let's see the output of <code>Instant#toString</code>:</p><pre><code class="lang-java">2013-05-30T23:38:23.085Z
</code></pre><p>Hold on, how and why is that printing years, months & etc? Well, an Instant can be converted into a calendar representation and  that's what the <code>toString&#40;&#41;</code> implementation does. That auto-conversion is the exception rather than the rule though, if you try to format an Instant as 'yyyy-mm-dd' you'll see what I mean.</p><p>On a related note, try adding a year to an Instant: </p><pre><code class="lang-clojure">&#40;-&gt; &#40;Instant/now&#41;
    &#40;.plus 1 ChronoUnit/YEARS&#41;&#41;
</code></pre><p>It compiles ok, but at runtime you'll get a run-time exception: <code>Unsupported Field : YearOfEra</code>. </p><p>So what's the problem here? People should just learn this basic fact about the java.time API before using it, right?</p><p>In practice, I see this issue about Instant and calendar-awareness come up a lot - via colleagues, github issues, stackoverflow & etc</p><p>My guess is that a lot of people only need to work with dates infrequently enough that they don't feel it's worth investing time going through the tutorials, or if they do, the nuances quickly fade through lack of practice.</p><p>Having seen this problem in the wild again and again for many years I have decided to take action! </p><p>If you now do some erroneous thing with Instant in cljc.java-time, like this:</p><pre><code>&#40;-&gt; &#40;cljc.java-time.instant/now&#41;
    &#40;cljc.java-time.instant/plus 1 cljc.java-time.temporal.chrono-unit/years&#41;&#41;
</code></pre><p>You get an exception with message:</p><pre><code>Hi there! - It looks like you might be trying to do something with a java.time.Instant that would require it to be 'calendar-aware', 
but since it isn't, it has no facility with working with years, months, days etc. 
To get around that, consider converting the Instant to a ZonedDateTime first or for formatting/parsing specifically, 
you might add a zone to your formatter. see https://stackoverflow.com/a/27483371/1700930. 
 
You can disable these custom exceptions by setting -Dcljc.java-time.disable-helpful-exception-messages=true
</code></pre><p>That message alone should at least prevent a lot of github issues and questions I get .... let's see!</p><p>I am adding that message because I think it's unlikely I could get java.time messages changed, I don't even  know how I would do that. I do know how to make this suggestion for the new date-time API being made for the world's most popular programming language though, raise <a href='https://github.com/tc39/proposal-temporal/issues/1233'>an issue!</a>. That improved error message may be my greatest contribution to humanity to date ;-)</p><h1>What about traditional wrappers like tick or clojure.java-time ?</h1><p>These are traditional wrappers and definitely come with trade-offs. In my work we use date logic a lot, which I think means it's an environment where it's worth learning to use a wrapper because of the extra+improved API. That being said, I use a wrapper for 80% of  regular date-arithmetic - for things I consider more obscure or esoteric, or where performance might suffer, I drop to cljc.java-time (which tick is using under the hood) - and in very rare cases - plain interop.</p><p>If you have any thoughts/questions, please let me know ;-)</p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/ecma-temporal-vs-java-time.html</id>
    <link href="https://widdindustries.com/blog/ecma-temporal-vs-java-time.html"/>
    <title>Temporal (Javascript's new Date-Time API) vs java.time (JSJoda on JS runtimes)</title>
    <updated>2020-08-02T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>If you are involved in the manufacture of computers in Europe then you're probably already aware that your friendly local 39th technical committee has it's own <a href='https://www.ecma-international.org/publications/standards/Ecma-262.htm'>toy scripting language</a>{:target="_blank"} and that language's support for  dates and times is somewhat lacking (<a href='https://www.youtube.com/watch?v=aVuor-VAWTI'>good talk on that</a>{:target="_blank"}).  Well, work is currently underway to change that  situation and in this post I'm going to compare the new API, called <code>Temporal</code>, to a similar effort from a few years back that was made for <code>Java</code> that resulted in a platform API called <code>java.time</code>.</p><p>At the time of writing <code>Temporal</code> (<a href='https://github.com/tc39/proposal-temporal/tree/2d35fa3ded4d8cef5d9a944365994ae60b5ed663'>sha</a>{:target="_blank"})  is 'Stage 2' meaning it's still a work in progress.  The Temporal authors have created a <a href='https://docs.google.com/forms/d/e/1FAIpQLSeYdvnDZZS6tKn18jiomfN7u_rq-_-_BqOevTzAcfgE3J4kHA/viewform'>survey</a>{:target="_blank"} for any feedback you might have.</p><p>There is already an <a href='https://github.com/tc39/proposal-temporal/issues/105'>open issue in the Temporal github</a>{:target="_blank"} to document comparison to other date-time libs and since that has been open for a year and a half already, I thought I'd make a start at least for comparison to one other lib, <code>java.time</code> aka (threeten), available to the JS world as <a href='https://js-joda.github.io/js-joda/'>JSJoda</a>{:target="_blank"}.</p><h1>Motivation</h1><p>I maintain a date-time library that targets both Javascript and the JVM (Java runtime), <a href='https://github.com/henryw374/cljc.java-time'>cljc.java-time</a>{:target="_blank"}.</p><p>It has the API of <code>java.time</code> and on JS platforms uses <a href='https://js-joda.github.io/js-joda/'>JSJoda</a>{:target="_blank"} under the hood. </p><p>So the value proposition is that users only need to know one API for both platforms and that the same date-time logic can be written to target  either or both.</p><p>Great though JSJoda is, it is not the platform API of Javascript of course and is by necessity a pretty chunky lot of JS code. If Temporal gets implemented on JS platforms then maybe JSJoda could be implemented on top of it, or my lib could drop JSJoda and  use Temporal directly.</p><h1>Comparison</h1><p><strong>Note:</strong> *Both <code>Temporal</code> and <code>JSJoda</code> are included in this page, so you can open your browser's JS console and paste in all of the  code snippets*.</p><p><em>tl;dr</em> IMO Temporal and java.time are very similar overall: they have mostly the same set of entities and there is support for going to and from the majority of  <a href='https://en.wikipedia.org/wiki/ISO_8601'>ISO8601</a>{:target="_blank"} representations). Temporal is a smaller API overall, but of course  the gaps could be filled by user libraries if desired.</p><p>I start by comparing the main entities and then go on to look at some specific use-cases that I think are interesting.  IOW this not a full comparison of every entity and method, but if there's something important you think is missing,  please mention it in the comments at the end. </p><h2>The main entities</h2><p>Temporal has a subset of the entities of java.time (see table below), but the entities it does have are what I guess the authors consider to be  the fundamental ones. Some names are different so <strong>in the discussion after, I'll only use the <code>java.time</code> entity names for clarity</strong>.</p><p><table>   <thead>     <tr>       <th><a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html" target="_blank">java.time</a></th>       <th><a href="https://github.com/henryw374/time-literals" target="_blank">Time Literal</a> Example</th>       <th>Temporal</th>     </tr>   </thead>   <tbody>     <tr>       <td>Instant</td>       <td><code class="language-plaintext highlighter-rouge">#time/instant "2018-07-25T07:10:05.861Z"</code></td>       <td>Absolute</td>     </tr>     <tr>       <td>ZoneId</td>       <td><code class="language-plaintext highlighter-rouge">#time/zone "Europe/London"</code></td>       <td>TimeZone</td>     </tr>     <tr>       <td>LocalDateTime</td>       <td><code class="language-plaintext highlighter-rouge">#time/date-time "2018-07-25T08:08:44.026"</code></td>       <td>DateTime</td>     </tr>     <tr>       <td>LocalDate</td>       <td><code class="language-plaintext highlighter-rouge">#time/date "2039-01-01"</code></td>       <td>Date</td>     </tr>     <tr>       <td>LocalTime</td>       <td><code class="language-plaintext highlighter-rouge">#time/time "08:12:13.366"</code></td>       <td>Time</td>     </tr>     <tr>       <td>YearMonth</td>       <td><code class="language-plaintext highlighter-rouge">#time/year-month "3030-01"</code></td>       <td>YearMonth</td>     </tr>     <tr>       <td>MonthDay</td>       <td><code class="language-plaintext highlighter-rouge">#time/month-day "12-25"</code></td>       <td>MonthDay</td>     </tr>     <tr>       <td>Period</td>       <td><code class="language-plaintext highlighter-rouge">#time/period "P1D"</code></td>       <td>Duration</td>     </tr>     <tr>       <td>Duration</td>       <td><code class="language-plaintext highlighter-rouge">#time/duration "PT1S"</code></td>       <td>Duration</td>     </tr>     <tr>       <td>DateTimeFormatter</td>       <td>n/a</td>       <td>(NOT PRESENT)</td>     </tr>     <tr>       <td>Clock</td>       <td>n/a</td>       <td>Temporal.now</td>     </tr>     <tr>       <td>Month</td>       <td><code class="language-plaintext highlighter-rouge">#time/month "JUNE"</code></td>       <td>(NOT PRESENT)</td>     </tr>     <tr>       <td>Year</td>       <td><code class="language-plaintext highlighter-rouge">#time/year "3030"</code></td>       <td>(NOT PRESENT)</td>     </tr>     <tr>       <td>ZonedDateTime</td>       <td><code class="language-plaintext highlighter-rouge">#time/zoned-date-time "2018-07-25T08:09:11.227+01:00[Europe/London]"</code></td>       <td>(TBD)</td>     </tr>     <tr>       <td>DayOfWeek</td>       <td><code class="language-plaintext highlighter-rouge">#time/day-of-week "TUESDAY"</code></td>       <td>(NOT PRESENT)</td>     </tr>     <tr>       <td>OffsetDateTime</td>       <td><code class="language-plaintext highlighter-rouge">#time/offset-date-time "2018-07-25T08:11:54.453+01:00"</code></td>       <td>(TBD)</td>     </tr>     <tr>       <td>OffsetTime</td>       <td><code class="language-plaintext highlighter-rouge">#time/offset-time "08:12:13.366+01:00"</code></td>       <td>(NOT PRESENT)</td>     </tr>   </tbody> </table></p><h2>Entity Mismatch</h2><h3>Period & Duration</h3><p>These entities represent a span of time which is not attached to a timeline.</p><p>java.time allows for negative spans, whereas Temporal does not yet - but <a href='https://github.com/tc39/proposal-temporal/issues/782'>looks like it will</a>.</p><p>A java.time Duration instance stores time as an amount of seconds, for example 5.999999999 seconds.</p><p>A java.time Period instance stores amounts of years, months and days, for example -1 years, 20 months and 100 days</p><p>A Period of 1 day, is not equivalent to to a Duration of 86400 seconds (24 hours) of course, because <code>1 day</code> is not always 24 hours, due to things like DST & leap seconds.</p><p>Temporal has combined these two entities into one, called Duration. Java has an equivalent entity <a href='https://www.threeten.org/threeten-extra/apidocs/org.threeten.extra/org/threeten/extra/PeriodDuration.html'>PeriodDuration</a>{:target="_blank"}  in the official addon lib for java.time. </p><p>Here is an example of adding a non-24-hour day in java.time</p><pre><code>z = JSJoda.ZoneId.of&#40;'Europe/Berlin'&#41;
zdt = JSJoda.LocalDateTime.parse&#40;'2019-03-31T00:00:00'&#41;.atZone&#40;z&#41;
zdtPlusDay = zdt.plusDays&#40;1&#41;
JSJoda.Duration.between&#40;zdt, zdtPlusDay&#41;.toString&#40;&#41;
=&gt; &quot;PT23H&quot; &#40;means 23 hours&#41;
</code></pre><p>The equivalent with Temporal operation is done with LocalDateTime, then converting the results to Instants  </p><pre><code>dt = Temporal.DateTime.from&#40;'2019-03-31T00:00:00'&#41;
dt2 = dt.plus&#40;{days: 1}&#41;
z = Temporal.TimeZone.from&#40;'Europe/Berlin'&#41; 
z.getAbsoluteFor&#40;dt2&#41;.difference&#40;z.getAbsoluteFor&#40;dt&#41;, {largestUnit: 'hours'}&#41;.toString&#40;&#41;
=&gt; &quot;PT23H&quot; &#40;means 23 hours&#41;
</code></pre><h3>Year, Month & DayOfWeek</h3><p>Temporal just uses numbers where java.time would use these entities. Like java.time though, numbering starts at 1.</p><p>Partly this may have been done because you don't get the same compile-time checks with JS, but also I would guess  this makes Temporal more easily work with other calendar systems. I imagine when working with non-Gregorian calendars in java.time one could avoid using Month and DayOfWeek.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html'>java.time.ZonedDateTime</a></h3><p>This entity represents a point on the timeline, in a place, an example being</p><pre><code>JSJoda.ZonedDateTime.parse&#40;&quot;2018-07-25T08:09:11.227+01:00&#91;Pacific/Honolulu&#93;&quot;&#41;
</code></pre><p>Temporal can parse that same string to an Instant, but it loses the zone/offset info</p><pre><code>Temporal.Absolute.from&#40;&quot;2018-07-25T08:09:11.227+01:00&#91;Pacific/Honolulu&#93;&quot;&#41;
</code></pre><p>In place of this, we can create objects containing a zone and either an Instant or a LocalDateTime.</p><p>There is a draft proposal for <a href='https://github.com/tc39/proposal-temporal/pull/700'>ZonedDateTime in Temporal</a>{:target="_blank"}</p><h3>OffsetTime & OffsetTime</h3><p>I've never had a use for OffsetTime, so let's skip over it.</p><p>OffsetDateTime functionality is contained within ZonedDateTime, so I'm not considering it separately.  </p><h2>Interesting Examples</h2><p>I am going to look at how to achieve various use-cases with both APIs, choosing examples I think are interesting.</p><h3>Calendar-aware time conversion</h3><p>Instant is not aware of calendars (e.g. DST, months, leap seconds etc), it's just a straightforward amount of nanos since an arbitrary  point in time. One  of the major noob java.time question topics stems from not being aware of this. For example trying to print the day of the month from an Instant doesn't work unless you provide a zone, or trying to add a year to  an Instant - that kind of thing.</p><p>Java.time refers to this topic as <a href='https://docs.oracle.com/javase/tutorial/datetime/iso/overview.html'>human vs machine time</a>{:target="_blank"} whereas  Temporal refers to entities as being 'Calendar-aware' or not, which seems a more self-explanatory definition. </p><p>Going from calendar-aware to Instant (non-calendar-aware) can involve disambiguation. For example on a DST change, a wall-clock time can happen twice (the clocks 'go back') or not at all (the clocks 'go forward').</p><h4>Disambiguation</h4><p>Here is an example of where we have a wall clock time that doesn't exist in a zone and are converting  it to a ZonedDateTime. See how we input the hour as '2', but it comes out as '3': <br /></p><pre><code>z = JSJoda.ZoneId.of&#40;'Europe/Berlin'&#41;
JSJoda.LocalDateTime.parse&#40;'2019-03-31T02:45:00'&#41;.atZone&#40;z&#41;.toString&#40;&#41;
=&gt; &quot;2019-03-31T03:45+02:00&#91;Europe/Berlin&#93;&quot; &#40;which is Instant &quot;2019-03-31T01:45:00Z&quot;&#41;
</code></pre><p><a href='https://tc39.es/proposal-temporal/docs/ambiguity.html'>Temporal docs section on resolving ambiguity</a>{:target="_blank"}</p><p>Temporal has the same default behaviour as java.time, but you can choose other options:</p><pre><code>tz = new Temporal.TimeZone&#40;'Europe/Berlin'&#41;;
dt = new Temporal.DateTime&#40;2019, 3, 31, 2, 45&#41;;
tz.getAbsoluteFor&#40;dt, { disambiguation: 'earlier' }&#41;; // =&gt; 2019-03-31T00:45Z
tz.getAbsoluteFor&#40;dt, { disambiguation: 'later' }&#41;; // =&gt; 2019-03-31T01:45Z
tz.getAbsoluteFor&#40;dt, { disambiguation: 'compatible' }&#41;; // =&gt; 2019-03-31T01:45Z
tz.getAbsoluteFor&#40;dt, { disambiguation: 'reject' }&#41;; // throws
</code></pre><p>A similar example would be finding out the wall clock time of when a day starts - it's not always midnight!</p><p>Here we find out that the day starts at 1 a.m.</p><pre><code>z = JSJoda.ZoneId.of&#40;&quot;America/Sao&#95;Paulo&quot;&#41;
JSJoda.LocalDate.parse&#40;'2015-10-18'&#41;.atStartOfDay&#40;z&#41;.toString&#40;&#41;
=&gt; &quot;2015-10-18T01:00-02:00&#91;America/Sao&#95;Paulo&#93;&quot; 
</code></pre><p>I'll leave it as an exercise for the reader to do the same in Temporal ;-)</p><h4>Arithmetic</h4><p>Since Instant isn't aware of calendars, you can add or take away seconds, but not months or years.</p><p>What about days though? As I said, a day is not 24 hours, but wrt Instant, Temporal treats it like it is:</p><pre><code>Temporal.now.absolute&#40;&#41;.plus&#40;{ months: 5 }&#41;; // fail - as expected
Temporal.now.absolute&#40;&#41;.plus&#40;{ days: 5 }&#41;; // no fail - days in this context means 24 hours
</code></pre><p>In fairness, so does java.time, so both APIs are consistent on this</p><pre><code>JSJoda.Duration.ofDays&#40;1&#41;.toString&#40;&#41;
=&gt; &quot;PT24H&quot;
</code></pre><h3>Truncation</h3><p>Example of truncating a java.time Instant to whole hours</p><pre><code>JSJoda.Instant.parse&#40;&quot;2020-07-30T21:29:54.697Z&quot;&#41;.truncatedTo&#40;JSJoda.ChronoUnit.HOURS&#41;.toString&#40;&#41;
=&gt; &quot;2020-07-30T21:00:00Z&quot;
</code></pre><p>Although <a href='https://tc39.es/proposal-temporal/docs/cookbook.html#round-a-time-down-to-whole-hours'>Temporal has facilities for Rounding</a>{:target="_blank"} using the <code>with</code> method, this just works on the fields a Temporal object has. Since Instant only has nanos field, it doesn't have a <code>with</code> method, so to achieve the above we go via a calendar aware object:</p><pre><code>z = Temporal.TimeZone.from&#40;'UTC'&#41;
dt = z.getDateTimeFor&#40;Temporal.Absolute.from&#40;&quot;2020-07-30T21:29:54.697Z&quot;&#41;&#41;
rounded = dt.with&#40;{minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 }&#41;
z.getAbsoluteFor&#40;rounded&#41;
=&gt; 2020-07-30T21:00Z
</code></pre><h3>Parsing & Formatting</h3><p>java.time has <a href='https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html'>DateTimeFormatter</a>{:target="_blank"}, which is used for converting to and from any string representation.</p><p>Temporal doesn't have an API for parsing, although there is an <a href='https://github.com/tc39/proposal-temporal/issues/796'>issue </a>{:target="_blank"}.</p><p>For printing, Temporal provides some facililities via <code>toString</code> - see <a href='https://tc39.es/proposal-temporal/docs/cookbook.html#zoned-instant-from-instant-and-time-zone'>here</a>{:target="_blank"}, and Intl.DateTimeFormat, as in <a href='https://tc39.es/proposal-temporal/docs/cookbook.html#zoned-instant-from-instant-and-time-zone'>this example</a>{:target="_blank"}</p><h3>Accessing Properties</h3><p>There is no direct equivalent of <a href='https://docs.oracle.com/javase/tutorial/datetime/iso/temporal.html'>java.time temporal package</a>{:target="_blank"}   in Temporal at present.  </p><p> You can access the fields of entities though, for example:  </p><pre><code>Temporal.DateTime.from&#40;'2019-03-31T00:00:00'&#41;.day
=&gt; 31 
</code></pre><h1>Conclusion</h1><p>Temporal and java.time are fundamentally similar. Temporal has a smaller API and possibly that results in something that's easier to learn, but results in more verbose code. Personally I value ease-of-learning much more. </p><p>Date-time logic is just like math: you can type stuff in and you'll get answers... but are they the right ones?  Have you got a type system that will let you know that you got it wrong? (please let me know if you do!) But it's not  like math because it's fundamentals are way more complex... so I just want to know one API and know it really well. Because of that I created a <a href='https://github.com/henryw374/cljc.java-time'>date-time library to target both Java and Javascript</a>{:target="_blank"}.  </p><p>So, of course I would have been happy if proposal-temporal had just decided to copy java.time! Well, they haven't, but that's not a show-stopper for lib by any means. It's great that Temporal is happening at all and hopefully will make it's way to our browsers and other JS runtimes in the near future.</p><p><script src="https://tc39.es/proposal-temporal/docs/playground.js" ></script> <script src="https://cdn.jsdelivr.net/npm/@js-joda/core@3.0.0/dist/js-joda.js"></script> <script src="https://cdn.jsdelivr.net/npm/@js-joda/timezone@2.3.0/dist/js-joda-timezone-10-year-range.js"></script>  <script src="https://cdn.jsdelivr.net/npm/@js-joda/locale_en-us@3.1.1/dist/index.min.js"></script></p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/tick-with-shadow-just-works.html</id>
    <link href="https://widdindustries.com/blog/tick-with-shadow-just-works.html"/>
    <title>Clojure(Script) date-time libs, Shadow-cljs &amp; Babashka</title>
    <updated>2020-05-31T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1>Time libs on npm/Shadow</h1><p><a href='https://github.com/juxt/tick'>tick</a> is a Clojure(Script) library for working with time. <a href='https://github.com/henryw374/cljc.java-time'>cljc.java-time</a> is used by tick and provides a cross-platform version of the java.time api. </p><p>In the latest releases, these 'just work' on Shadow-cljs, for example:</p><pre><code>echo '{:deps { tick {:mvn/version &quot;0.4.25-alpha&quot;} thheller/shadow-cljs {:mvn/version &quot;2.9.8&quot;} }}' &gt; deps.edn
echo '{:deps {}}' &gt; shadow-cljs.edn
echo '{}' &gt; package.json

npm install shadow-cljs --save-dev &amp;&amp; npx shadow-cljs browser-repl
</code></pre><p>In the repl:</p><pre><code>cljs.user=&gt; &#40;require '&#91;tick.alpha.api :as t&#93;&#41;
nil
cljs.user=&gt; &#40;t/today&#41;
#time/date &quot;2020-05-31&quot;

</code></pre><p>Why is this news? Well, previously Shadow and other npm-using Clojurescript users of Tick/cljc.java-time had to include an extra shim library and manually include the js-joda dependencies in their package.json. A desire to move to the latest (and now scope-named) '@js-joda/core' packages, <a href='https://clojure.atlassian.net/browse/CLJS-3138'>a fix in the latest Clojurescript release</a> and an increase in my understanding of <a href='http://widdindustries.com/cljs-npm-libraries/'>how to package Clojurescript libraries</a> has resulted in these improvements. Note, there are still a few <a href='https://github.com/juxt/tick/blob/master/docs/cljs.adoc'>need-to-knows for Clojurescript users</a>, but not too many!</p><h1>Babashka</h1><p>In other news <a href='https://github.com/henryw374/cljc.java-time'>cljc.java-time</a> now works on a third platform, <a href='https://github.com/borkdude/babashka/'>babashka</a>!</p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/cljs-npm-libraries.html</id>
    <link href="https://widdindustries.com/blog/cljs-npm-libraries.html"/>
    <title>How to package Clojurescript libraries</title>
    <updated>2020-04-17T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1>Update (2021-07-18)</h1><p>The Reagent project, one of the better known cljs projects that depends on a javascript lib, has abandoned Clojurescript's dependency mechanisms (foreign-libs or deps.cljs) entirely, making users bring their own React, see <a href='https://github.com/reagent-project/reagent/issues/537'>this issue</a> for details.</p><p>Original content from here on :</p><p>If you are authoring a Clojurescript library that doesn't depend on any regular Javascript (JS) code, transitively or otherwise then things are pretty straightforward: maven-package your library and put it in Clojars - job done!</p><p>Still reading? OK, well things are not as straightforward when libs do depend on JS code. As of this writing there is no guide I know of that explains everything you'd need to know, so think of this as a first draft of such a guide. Ideally the content here could go on to be included in the <a href='https://clojurescript.org/'>Clojurescript Site</a>, as a solution for open tickets such as <a href='https://github.com/clojure/clojurescript-site/issues/224'>this</a>. Also note that what I describe here all works since the <a href='https://clojurescript.org/news/2020-04-24-release'>April 2020 release of Clojurescript</a> - There were some changes in that release that significantly improve the situation regarding libraries.</p><p>The main consideration is how to package a library so that Clojurescript users can consume it, whatever their build setup. To that end, I have created <a href='https://github.com/henryw374/clojurescript-library-consumers-test'>this companion repo</a> to demonstrate different Cljs build setups (Shadow, target-bundle, cljsjs, npm-deps) all consuming the same (npm-depending) library and all targeting the same thing: a browser build with advanced optimizations. The library used as an example is one of mine, called <a href='https://github.com/henryw374/cljs.java-time'>cljs.java-time</a>. This uses code from a single, standalone npm library 'js-joda' - so about as straightforward an example as you can get.</p><h1>Brief Background</h1><p>In Clojure (JVM) land, consuming maven-packaged Java libraries is seamless and ubiquitous. If you find a Clojure library that looks useful and that library ultimately depends on one or more Java libraries, then installation will not an issue. The Java libraries will get pulled down along with all the Clojure libraries and the overall artifact size won't likely be a major concern, within reason.</p><p>With Clojurescript, it's a bit different. Having a low overall artifact sizes may be crucial to your users for one thing. For another, regular JS libs are stored in NPM, which Clojure dependency tools like tools.deps do not currently work with. </p><p>Clearly having Clojurescript libraries depending on plain JS is possible, and has been since the early days of Clojurescript via <code>:foreign-libs</code>, but for good reasons the story doesn't end there. JS-using libraries (like <a href='https://github.com/reagent-project/reagent'>Reagent</a> for example) usually have something in the README to explain how to consume them - because it's not as straightforward as on the JVM.</p><h2>Why would Clojurescript libraries depend on NPM libraries?</h2><p>A maven-packaged ecosystem exists that shadows a lot of stuff from npm, called <a href='https://github.com/cljsjs/packages'>Cljsjs</a>, so why would anyone bother complicating their build with a second dependency/build tool?</p><ul><li>End users might have a set up where they want code from npm libraries A and B, which both depend on npm library C, but possibly different versions of C. People don't want to be in the business of sorting out these kinds of situations by hand. Thomas Heller goes into <a href='https://code.thheller.com/blog/shadow-cljs/2017/09/15/js-dependencies-the-problem.html'>more detail about why Cljsjs doesn't scale</a>.</li><li>Users are already happily using npm and don't want to have to package up foreign-libs for everything.</li></ul><p>IOW - if people are using more than one or two JS libraries in their Clojurescript build, then using npm will likely be their preferred solution. Shadow-Cljs is one popular way to set that up and the newly released <code>:bundle</code> target in Clojurescript is an alternative. </p><h2>Should your Library depend on Cljsjs?</h2><p>We can't say what proportion of Cljs users are using npm in their build, but we can try to use some proxies to guess. The <a href='https://clojure.org/news/2020/02/20/state-of-clojure-2020'>Clojure survey</a> doesn't ask this specifically unfortunately, but what we can see is that there is still plenty of <a href='https://github.com/cljsjs/packages/graphs/commit-activity'>activity in the Cljsjs repo</a>. It be good to see the graph over time of Clojars downloads of Cljsjs packages too... tbd. I would expect to see use of Cljsjs diminish over time, but my feeling is that it's not going to be abandoned any time soon. </p><p>It is an option to have your library <em>not</em> depend on any Cljsjs libraries and have instructions in your readme for non-npm users that they'll need to add the Cljsjs dependencies themselves. This might be ok if the underlying npm libs are few and are not likely to change much - otherwise upgrading will be somewhat painful for users. </p><p>Another consideration if your lib does depend on Cljsjs libraries will be users targeting Node. Unless they are using Shadow, <code>:foreign-libs</code> will be picked up but they work a bit strangely because <a href='https://github.com/clojure/clojurescript-site/issues/320'>every 'require' results in the foreign lib being evaluated</a>, so prepare for some confused users or take steps to mitigate it, as <a href='https://github.com/henryw374/packages/commit/13958337d9ba2e04563c03076bba24be6e1b0921'>I did with js-joda</a>.</p><p>In summary, you can decide if the (potential) users of your lib are likely to be the ones using npm already or not. If they might not use npm, and the Cljsjs dependency tree doesn't look too hairy, then perhaps you would decide to have Cljsjs dependencies for the time being.</p><h1>Authoring</h1><h2>Cljsjs</h2><p>Assuming you do want to package one or more Cljsjs libraries (whether your lib declares a dependencies on them or not), you need to look at packaging 'foreign-libs' that will contain all the code that would have come from npm (if they don't exist already in CLJSJS of course). What makes this code 'foreign' in Cljs parlance is that is not written in Google Closure style (<a href='https://developers.google.com/closure'>Google Closure</a> is a key tool the Clojurescript compiler uses under the hood). The npm code you want to consume may actually be amenable to Dead Code Elimination by Closure but let's ignore that for now.</p><p>Create a library that just packages one npm library and submit a PR to cljsjs. Cljsjs has a helpful <a href='https://github.com/cljsjs/packages/wiki'>wiki</a> with guides and explainers.</p><p>That Cljsjs library will contain a <code>deps.cljs</code> file that looks something like this:</p><pre><code>{:foreign-libs
 &#91;{:file &quot;cljsjs/js-joda-core/js-joda.inc.js&quot;,
   :provides &#91;&quot;@js-joda/core&quot;&#93;,
   :global-exports {&quot;@js-joda/core&quot; JSJoda}}&#93;&#93;
 :externs &#91;&quot;cljsjs/js-joda/common/js-joda.ext.js&quot;&#93;}
</code></pre><p>There are more opts you might need, see <a href='https://clojurescript.org/reference/compiler-options#foreign-libs'>the full list here</a> for more info. </p><p>Note though that I am packaging <code>:externs</code> here. Users of your library should use compiler opt <code>:infer-externs true</code>, but for the Cljs.java-time library, that is not sufficient to survive advanced compilation. You can use the <a href='https://github.com/henryw374/clojurescript-library-consumers-test'>library consumers test</a> to see if you need hand-rolled externs for your library or not.</p><p>One important point for npm-compatibility is what you put in <code>:provides</code> and they keys of <code>:global-exports</code> - the name (in this example <code>@js-joda/core</code>) <strong>must exactly match that of the npm package name</strong>.</p><p>With this setup, your library code ns can require the JS lib like so:</p><pre><code>&#40;ns my-cool-lib
  &#40;:require &#91;&quot;@js-joda/core&quot; :as joda&#93;&#41;&#41;
  </code></pre><br /><p>Importantly, this require will work for both foreign-lib/Cljsjs users and npm users.<br /></p><p>Now you have a mvn-packaged foreign-lib, your library pom.xml can depend on it as it would any other non-npm lib.</p><h2>Npm</h2><p>Package a <code>deps.cljs</code> file with your lib with contents like this:</p><pre><code>{:npm-deps {&quot;@js-joda/core&quot; &quot;1.12.0&quot;}
 :externs &#91;&quot;cljsjs/js-joda/common/js-joda.ext.js&quot;&#93;}
</code></pre><p>This example is from <code>cljs.java-time</code> again and in this case just lists a single npm library and the required  npm version. The same externs file that was packaged with the Cljsjs library is included here as well because the npm-using users of your library will exclude the Cljsjs dependency to avoid getting the foreign-lib as well (Shadow users won't need to as it ignores foreign-libs) but they will still need the externs. </p><p>Note that <code>:npm-deps</code> dependency in deps.cljs is <strong>not</strong> tied to Google Closure processing (it was in the past).</p><h1>How consumers will install your library</h1><p>The best thing I can do to explain the possibilities here is to point you to the <a href='https://github.com/henryw374/clojurescript-library-consumers-test'>library consumers test</a>. This actually demonstrates all of the possible ways your library could be consumed by users targeting browsers and examples of how to do so.</p><p>The test includes an example compiling with <code>:npm-deps true</code> option but if that doesn't work, don't fret, it is <a href='https://clojurescript.org/reference/compiler-options#npm-deps'>not recommended</a></p><h1>Wrap-up</h1><p>React wrappers aside, afaik there aren't that many Cljs libs depending on plain-JS libraries right now - in some cases that might be because it has been seen as complicated, but as this guide shows, it's not rocket science. </p><p>I would advocate a change to Clojurescript that introduces a new compiler opt <code>:use-foreign-libs-from-deps?</code> that defaults to <code>false</code>. That would mean the non-Shadow npm users didn't have to track down and exclude Cljsjs dependencies from their build and hopefully act as a clear statement that Cljsjs is no longer the recommended path.</p><p>The situation for library authors would of course be more straightforward if all Cljs users were using npm, but I guess a signifcant proportion don't. It would be cool if the Clojure survey could track that more precisely. <a href='https://github.com/funcool/cuerdas'>Cuerdas</a> is one such Cljsjs-depending library, and has clearly had <a href='https://github.com/funcool/cuerdas/commit/a8443724e22435e052af4149b27dd2169f3216ac'>some issues</a> when they try to drop the Cljsjs dependency. </p><p>As I say this guide is correct to the best of my knowledge and is something I would have found really helpful when first creating a Clojurescript library. If you have any feedback, corrections etc, I'd love to know!</p><p>& Thanks to David Nolen for explaining some of the finer points to me! </p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/clojure-time-libs-update.html</id>
    <link href="https://widdindustries.com/blog/clojure-time-libs-update.html"/>
    <title>Progress update on the Clojure(Script) date-time libraries</title>
    <updated>2020-01-05T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>In April 2019 I gave a <a href='https://www.youtube.com/watch?v=UFuL-ZDoB2U'>talk at Clojure/North</a> providing my motivation for working on new date-time libraries: <code>cljc.java-time</code>, <code>time-literals</code> and <code>tick</code>. Yes, you heard right, yet more date-time libraries! In the talk I argue that they provide novelty with respect to cross-platform development and improve the overall situation for Clojurescript date-time work. This post gives some updates on what has happened since and considers future developments for these libraries.</p><p>It's always hard to know how much usage open source projects are getting, but these young libraries are definitely seeing some healthy activity in terms of Github issues, contributions and stars. As expected, tick has had the majority of activity, but I'm aware of people using the ancillary libs in isolation too. </p><p>For the rest of the post I'll talk about the todo list that I presented in the Clojure/North talk, how it has progressed and what's new on the list. I'd welcome PRs on any of these items but if you want any of them expedited by myself then please <a href='http://widdindustries.com/about/'>get in touch</a> </p><h1><a href='https://github.com/henryw374/time-literals'>Time Literals</a></h1><p>Useful to any Clojurist working with java.time, either with or without a wrapper library. java.time entities are printed as tagged literals that can be pasted back in to the REPL, written to files, sent over the wire and so on. </p><p>Examples:</p><pre><code> #time/date&quot;1969-07-20&quot;
 #time/time&quot;20:17&quot;
</code></pre><h2>Todo</h2><p>There has been some interest in having Transit encodings using the literals. Support for the <code>datafy/nav</code> is another possible feature, but although it has a similar theme of representing data, it isn't that closely related to <code>time-literals</code> so might live in a separate repo.</p><h1><a href='https://github.com/henryw374/cljc.java-time'>cljc.java-time</a></h1><p>This is a  Clojure(Script) library that mirrors the java.time api through kebab-case-named vars. </p><pre><code>&#40;ns my.cljc
  &#40;:require  &#91;cljc.java-time.local-date :as ld&#93;&#41;
  
  ;create a date
  &#40;def a-date &#40;ld/parse &quot;2019-01-01&quot;&#41;&#41;
  
  ;add some days
  &#40;ld/plus-days a-date 99&#41;
</code></pre><h2>Progress</h2><p>As this library only aims to mirror java.time and is generated from it, the api was essentially 'done' on the first release. The type hinting has been improved since then, thanks to work which has now become <a href='https://github.com/emlyn/tortilla'>Tortilla</a>)</p><p>Having (clojure.spec) specs and generators for java.time is something I <a href='https://github.com/henryw374/time-literals'>made a start</a> on, but while spec itself is changing then any lib using it is going to be subject to the same flux. There has been some interest in having <a href='https://github.com/metosin/malli'>Malli</a> use cljc.java-time for it's date and time logic, but IMO cljc.java-time brings too much baggage on the Clojurescript side - although read on to the next section for a possible way through for this and other libraries.</p><p>Whatever direction these specification efforts take, a set of predicate functions for the java.time entities is a generally useful thing and a recent contribution to cljc.java-time added instance predicates for all java.time entities, for example <code>&#40;date? x&#41;</code>. </p><p>The other <a href='https://github.com/henryw374/cljc.java-time/issues'>open issues</a> are about listing discrepancies between the underlying time libs and wrapping the further flung corners of java.time.</p><h1><a href='https://github.com/henryw374/cljs.java-time'>cljs.java-time</a></h1><p>This Clojurescript library is used by <code>cljc.java-time</code> (see above). It exposes the npm library <a href='https://github.com/js-joda/js-joda'>Js-Joda</a> (a faithful and mostly complete JS implementation of java.time) and extends the Clojurescript equivalence, comparison and hashing protocols to its entitites.</p><p>Because js-joda existed, it was a relatively small step to make a cross-platform time library, but although it is an enabler it is also something of a hindrance for two main reasons:</p><p>1) The myriad ways Clojurescript users consume npm libraries</p><p>2) It's size (minimum of 43k, gzipped)</p><p>On point 1), making a Clojurescript library that uses an npm lib sometimes feels a bit like being in the wild west, but at the end of the day, whatever setup you have it's not too hard to get this library working and if you can consume foreign-libs, it 'just works' out of the box. Having a single command that will drop you into a node repl with tick is pretty cool, for example:</p><pre><code>clj -Sdeps '{:deps {org.clojure/clojurescript {:mvn/version &quot;1.10.597&quot; } tick {:mvn/version &quot;0.4.23-alpha&quot;} }}' -m cljs.main  -re node  --repl
</code></pre><p>Regarding point 2), I would say that in many contexts (including client projects I am currently engaged in) the size is simply not an issue when trading off </p><ul><li>utility</li><li>overall build size</li><li>actual end user's experience</li></ul><p>In other contexts the size would be a problem though. I have briefly looked into reducing its size through minification & Dead Code Elimination and although I've made a little progress I don't think it's going to be possible to reduce it enough to bring it down hugely or to be on a par with <code>goog.date</code>.</p><p>These two issues together mean that <code>cljs.java-time</code> & related libs probably aren't going to be used by other Clojure(Script) libraries needing date/time functions.</p><p>I'd say the best looking solution on the horizon is the new platform date-time library being developed for Javascript aka <a href='https://github.com/tc39/proposal-temporal'>tc-39/proposal-temporal</a> (hereafter PT). If JS had a good date-time api built-in then it wouldn't be necessary to bring your own of course, so no need for Js-Joda and problems 1) and 2) go away, simples!</p><p>The PT api is currently being finalized and experimental work is underway to reimplement <a href='https://github.com/moment/moment'>Moment.js</a> with it. How far away it is from being included in the next version of Node, Chrome etc I really can't say. Even when it is there, the world's browsers won't get upgraded overnight so polyfills will be needed for some time in many cases. </p><p>That aside, what does PT look like? Unfortunately from a cross-platform lib developer's PoV it is not that similar to java.time. Some obvious differences are naming and the entities where methods reside. Also there is no ZonedDateTime and the Duration and Period classes have been combined. However, although it looks pretty different, my feeling is that the differences are quite superficial. If you wanted a cross platform Clojure api that used PT and java.time, I think extending tick's protocols to the PT entities would likely be a good starting point, so you might end up with a <code>tick-lite</code> that doesn't use js-joda or any npm lib.</p><h1><a href='https://github.com/juxt/tick'>tick</a></h1><p>This is a <a href='https://juxt.pro/index.html'>Juxt</a> library that I made cross-platform and am now helping to maintain. I'll try to briefly describe it as having the following features: </p><p>1) A single-ns, intuitive api over java.time</p><p>2) Batteries-included - it depends on and configures <code>cljc.java-time</code>, <code>time-literals</code> & additional js-joda locale & timezone libs</p><p>3) Power tools - Interval Algebra and Scheduling</p><p>Unsurprisingly <code>tick</code> appears to have the most traction of all the libs (despite its alpha status) and it's been great to see a number of bug fixes and minor contributions from the community since April.</p><p>In the main api the things I'd most like to be addressed include:</p><ul><li>parsing (defer to DateTimeFormatter entirely)</li><li>another look at <code>&gt;&gt;/&lt;&lt;</code> vs <code>+/-</code> and <code>range</code></li><li>more <a href='https://juxt.pro/tick/docs/index.html'>documentation of tick</a>.</li></ul><p>See the full list of <a href='https://github.com/juxt/tick/issues'>issues</a> for other open items.</p><h1>Conclusion</h1><p>It has been good to see a positive response to the talk and the libraries. In summary, there have been some minor bug fixes & tweaks since April, but I've outlined what I see as some potential features that could exist in future - if people want them! As I say, I'd welcome PRs on any of these items but if you want any of them expedited by myself then please <a href='http://widdindustries.com/about/'>get in touch</a>.  <br /></p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/cljs-async-tests.html</id>
    <link href="https://widdindustries.com/blog/cljs-async-tests.html"/>
    <title>Less Boilerplate in Cljs Async Tests</title>
    <updated>2019-09-04T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>I can mostly avoid async tests for my re-frame cljs apps. Even integration-style tests that  use <a href='https://github.com/airbnb/enzyme'>enzyme</a> or <a href='https://github.com/testing-library/react-testing-library'>react-testing-library</a>  can be made synchronous (if using Re-frame), by using <code>day8.re-frame.test/run-test-sync</code> and faking server responses  with synchronous promises. This is nice because they're easier to understand and debug.  Sometimes though, async is necessary. </p><p>The Clojurescript site describes <a href='https://clojurescript.org/tools/testing'>how to do async tests</a> using the <code>cljs.test/async</code> macro and Re-frame has a nice <code>run-test-async</code> wrapper around that. </p><p>If you are using <code>cljs.test/async</code> you have to make sure your test code calls the <code>done</code> function in every case, including  on errors, timeout etc. So to remove some boilerplate, here's a new <a href='https://github.com/henryw374/Cljs-Async-Timeout-Tests'>utility</a> which provides a macro like <code>cljs.test/async</code>, but which on timeout or uncaught failure (exception or failed promise), will fail the test,  calling the <code>done</code> function for you.</p><p>Here's how you'd use it:</p><pre><code>&#40;ns myns.ns
  &#40;:require &#91;clojure.test :refer &#91;is deftest&#93;&#93;
            &#91;widdindustries.timeout-test :refer &#91;async-timeout async-timeout-at&#93;&#93;&#41;&#41;

&#40;deftest my-test
  &#40;async-timeout done 
     ;; do some stuff that will call `done` when it succeeds.
     ;; lib expects any async body will result in a promise
   &#41;&#41;
</code></pre><p>If you have any feedback please comment or raise an issue.</p><p>Henry</p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/clojure-north.html</id>
    <link href="https://widdindustries.com/blog/clojure-north.html"/>
    <title>Cross-Platform Date-Time Awesomeness</title>
    <updated>2019-04-23T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>Watch <a href='https://www.youtube.com/watch?v=UFuL-ZDoB2U'>my talk</a> from the <code>Clojure/North 2019</code> conference, </p><p><a href='/blog/assets/clojure-north-2019_.pdf'>Slides here</a></p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/with-redefs-problems.html</id>
    <link href="https://widdindustries.com/blog/with-redefs-problems.html"/>
    <title>When to avoid with-redefs</title>
    <updated>2019-01-07T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p><a href='https://clojuredocs.org/clojure.core/with-redefs'>with-redefs</a> is a handy clojure.core function to use when you want to redefine one or more vars temporarily (within a block) and you want these redefinitions to apply across thread boundaries</p><p>An alternative for doing something similar is <a href='https://clojuredocs.org/clojure.core/with-bindings'>with-bindings</a>, and that is slightly different in that the new bindings are only seen within the context of the current thread. If for example, you use with-bindings on a var and the value of the var is referenced when doing a <code>clojure.core/map</code> operation say, then it is possible you won't see the temp binding, since <code>map</code> is lazy and may be executed in a different thread.</p><p>Also, <code>with-bindings</code> requires the rebound vars are dynamic. </p><p>So... with-redefs is generally a more powerful go-to tool than with-bindings?</p><p>No, <code>with-bindings</code> is more generally used on vars that are planned to get rebound, whereas <code>with-redefs</code> is intended when you want to change the way things normally work, for example when you're running a test and decide you don't really want to call an external system, and can use with-redefs to stub.</p><p>However, beware that <code>with-redefs</code> is not foolproof. Consider rebinding a function foo</p><pre><code>&#40;with-redefs &#91;a.b.c/foo my-temp-fn&#93;
  ... body that calls foo at some point, possibly from another thread&#41;
</code></pre><p>Will the body here always see your temp binding?</p><p><strong>No</strong></p><p>Why not?</p><p>Well, interleaved threads is one situation. </p><p>Let's say this code is called from two threads and this is the order of events:</p><p>Thread A executes the <code>with-redefs</code></p><p>Thread B executes the <code>with-redefs</code></p><p>Thread A executes the body and exits the <code>with-redefs</code> block (thereby restoring the root binding of foo)</p><p>Thread B now executes the body and does not see the temp binding!!</p><p>The docs for <code>with-redefs</code> say this is handy for tests, which implies that if you want to change a var in non-test code, then <code>alter-var-root</code> (assuming it is done once, on startup) is the way to go. </p><p>However, there's nothing to stop you hitting an interleaving problem in tests unless you are running your tests serially and the with-redef wraps the test body. There isn't a <code>with-redefs-visible-only-via-this-block</code> or equivalent.</p><h3>Conclusion:</h3><p>Use <code>with-redefs</code> cautiously. Remember this blog post when scratching your head about why some code is not seeing a temp binding.</p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/cross-platform.html</id>
    <link href="https://widdindustries.com/blog/cross-platform.html"/>
    <title>Simplify Your Business Logic</title>
    <updated>2018-09-17T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>A brief explanation of how to leverage your business logic code as much as possible by <a href='https://www.infoq.com/presentations/Simple-Made-Easy'>Simplifying</a> it, with some specific tips for Clojure developers, including using the cross-platform <a href='https://github.com/juxt/tick'>tick</a> date/time library.</p><h2>Separate Decisions from Dependencies</h2><p>The idea to 'Separate Decisions from Dependencies' is to only use pure functions for writing code that 'makes decisions' and wire those functions together as necessary with all the plumbing bits of your system (that'll get your data to and from databases/services/users etc).  Rich Hickey would call such a separation a <a href='https://www.infoq.com/presentations/Simple-Made-Easy'>Simplification</a>.</p><p>Maybe you think you are doing this already, but ask yourself:</p><p><b>Is all your business logic available cross-platform?</b> </p><p>For Clojurists that means your business logic is (or could be) in .cljc files. For  JS/Node developers that generally means all your business logic modules are free of IO.</p><p>Doing this should be zero-cost, but I rarely see it in the wild. </p><h3>Why Cross-Platform ?</h3><p>Many authors and speakers have expounded the virtues of <i>Separating Decisions from Dependencies</i>  or <i>Isolating Computation From State</i> [1], typically citing reliability/testability/visibility as benefits. I am totally in agreement with them, but why go  further and say Decisions code must be cross platform?</p><p>Thinking here of a typical modern web/mobile application, we have situations like:</p><ul><li>A user of the front end wants to explore taking an action of some sort and the app needs to respond as fast aspossible to show consequences, ideally without any server round-trip. Then later, on completion, some back end code must validatethe input, use it to carry out actions, schedule jobs & etc. </li><li>A screen of the app shows the user some derived data. The app also needs to periodically email userswith the same derived data (think bank account summary).</li><li>A screen in the app shows a data summary of some sort. A user can drill-down into some detail and the serversends more specific data covering the required slice of the overall dataset. Some of the calculations on the detail screen are the same as those that were used to make the output for the summary screen.</li></ul><p>In all these situations we need to have the same logic wherever the app runs. </p><p>Cross-Platform business logic is not typically available in stacks where the various app components (web ui, mobile app, server) are on disparate platforms. Clojure and Node are two stacks where I've personally used this idea to great effect, including on Mobile applications written on  React Native.</p><p>Briefly stated, if you've not got cross-platform logic the problems you might have are:</p><ul><li>Needless duplication - I don't need to say any more</li><li>Storing up trouble - "User: Ooh, nice feature, can we have that on the <i>insert other platform here</i> as well?"</li><li>Decisions relying on Dependencies - usually cases that somehow slipped in when you weren't looking</li></ul><h3>Known Issues?</h3><p>The JVM and JS runtimes differ significantly, for the purposes of business logic that usually means:</p><ul><li>Dates & Times: Until now, we've been making do with clj/s-time [2] but now there is a betteroption <b><a href='https://github.com/juxt/tick'>tick</a></b>, which is an intuitive Clojure(Script) api over the <em>java.time</em> api. </li><li>Numbers: There's just the one number type in JS, but many on the JVM. This may be a blocker for some, I'll aim to revisit in a later post.</li><li>String Formatting: No clojure.core/format equivalent exists in Cljs. Instead try <a href='https://github.com/alexei/sprintf.js'>Sprintf</a></li></ul><p>[1] A couple of my favourites are Gary Bernhardt's <a href='https://eventil.com/talks/jYSOmz-gary-bernhardt-boundaries'>Boundaries</a>  and Stuart Sierra's <a href='https://www.infoq.com/presentations/Thinking-in-Data'>Thinking in Data</a>.  </p><p>[2] <a href='https://github.com/andrewmcveigh/cljs-time'>cljs-time</a> only partially implements clj-time. Working in finance as I mostly do, dates are everywhere and the  differences too often <a href='https://github.com/andrewmcveigh/cljs-time/issues/92'>leak out</a></p>]]></content>
  </entry>
  <entry>
    <id>https://widdindustries.com/blog/Hello.html</id>
    <link href="https://widdindustries.com/blog/Hello.html"/>
    <title>Hello, World!</title>
    <updated>2018-09-04T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>I've heard blogging is the brand new hotness so I'm giving it a go</p>]]></content>
  </entry>
</feed>
